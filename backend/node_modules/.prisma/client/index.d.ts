
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Period
 * 
 */
export type Period = $Result.DefaultSelection<Prisma.$PeriodPayload>
/**
 * Model EvaluationParameter
 * 
 */
export type EvaluationParameter = $Result.DefaultSelection<Prisma.$EvaluationParameterPayload>
/**
 * Model Evaluation
 * 
 */
export type Evaluation = $Result.DefaultSelection<Prisma.$EvaluationPayload>
/**
 * Model EvaluationScore
 * 
 */
export type EvaluationScore = $Result.DefaultSelection<Prisma.$EvaluationScorePayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model CkpScore
 * 
 */
export type CkpScore = $Result.DefaultSelection<Prisma.$CkpScorePayload>
/**
 * Model FinalEvaluation
 * 
 */
export type FinalEvaluation = $Result.DefaultSelection<Prisma.$FinalEvaluationPayload>
/**
 * Model AspekPenilaian
 * 
 */
export type AspekPenilaian = $Result.DefaultSelection<Prisma.$AspekPenilaianPayload>
/**
 * Model RentangNilai
 * 
 */
export type RentangNilai = $Result.DefaultSelection<Prisma.$RentangNilaiPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  STAFF: 'STAFF',
  ADMIN: 'ADMIN',
  PIMPINAN: 'PIMPINAN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Gender: {
  LK: 'LK',
  PR: 'PR'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const EvaluationStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED'
};

export type EvaluationStatus = (typeof EvaluationStatus)[keyof typeof EvaluationStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type EvaluationStatus = $Enums.EvaluationStatus

export const EvaluationStatus: typeof $Enums.EvaluationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.period`: Exposes CRUD operations for the **Period** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Periods
    * const periods = await prisma.period.findMany()
    * ```
    */
  get period(): Prisma.PeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evaluationParameter`: Exposes CRUD operations for the **EvaluationParameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaluationParameters
    * const evaluationParameters = await prisma.evaluationParameter.findMany()
    * ```
    */
  get evaluationParameter(): Prisma.EvaluationParameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evaluation`: Exposes CRUD operations for the **Evaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluations
    * const evaluations = await prisma.evaluation.findMany()
    * ```
    */
  get evaluation(): Prisma.EvaluationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evaluationScore`: Exposes CRUD operations for the **EvaluationScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaluationScores
    * const evaluationScores = await prisma.evaluationScore.findMany()
    * ```
    */
  get evaluationScore(): Prisma.EvaluationScoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ckpScore`: Exposes CRUD operations for the **CkpScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CkpScores
    * const ckpScores = await prisma.ckpScore.findMany()
    * ```
    */
  get ckpScore(): Prisma.CkpScoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.finalEvaluation`: Exposes CRUD operations for the **FinalEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinalEvaluations
    * const finalEvaluations = await prisma.finalEvaluation.findMany()
    * ```
    */
  get finalEvaluation(): Prisma.FinalEvaluationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aspekPenilaian`: Exposes CRUD operations for the **AspekPenilaian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspekPenilaians
    * const aspekPenilaians = await prisma.aspekPenilaian.findMany()
    * ```
    */
  get aspekPenilaian(): Prisma.AspekPenilaianDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rentangNilai`: Exposes CRUD operations for the **RentangNilai** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RentangNilais
    * const rentangNilais = await prisma.rentangNilai.findMany()
    * ```
    */
  get rentangNilai(): Prisma.RentangNilaiDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.0
   * Query Engine version: 9c30299f5a0ea26a96790e13f796dc6094db3173
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Period: 'Period',
    EvaluationParameter: 'EvaluationParameter',
    Evaluation: 'Evaluation',
    EvaluationScore: 'EvaluationScore',
    Attendance: 'Attendance',
    CkpScore: 'CkpScore',
    FinalEvaluation: 'FinalEvaluation',
    AspekPenilaian: 'AspekPenilaian',
    RentangNilai: 'RentangNilai'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "period" | "evaluationParameter" | "evaluation" | "evaluationScore" | "attendance" | "ckpScore" | "finalEvaluation" | "aspekPenilaian" | "rentangNilai"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Period: {
        payload: Prisma.$PeriodPayload<ExtArgs>
        fields: Prisma.PeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>
          }
          findFirst: {
            args: Prisma.PeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>
          }
          findMany: {
            args: Prisma.PeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>[]
          }
          create: {
            args: Prisma.PeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>
          }
          createMany: {
            args: Prisma.PeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>[]
          }
          delete: {
            args: Prisma.PeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>
          }
          update: {
            args: Prisma.PeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>
          }
          deleteMany: {
            args: Prisma.PeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>[]
          }
          upsert: {
            args: Prisma.PeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>
          }
          aggregate: {
            args: Prisma.PeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePeriod>
          }
          groupBy: {
            args: Prisma.PeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PeriodCountArgs<ExtArgs>
            result: $Utils.Optional<PeriodCountAggregateOutputType> | number
          }
        }
      }
      EvaluationParameter: {
        payload: Prisma.$EvaluationParameterPayload<ExtArgs>
        fields: Prisma.EvaluationParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationParameterPayload>
          }
          findFirst: {
            args: Prisma.EvaluationParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationParameterPayload>
          }
          findMany: {
            args: Prisma.EvaluationParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationParameterPayload>[]
          }
          create: {
            args: Prisma.EvaluationParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationParameterPayload>
          }
          createMany: {
            args: Prisma.EvaluationParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationParameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationParameterPayload>[]
          }
          delete: {
            args: Prisma.EvaluationParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationParameterPayload>
          }
          update: {
            args: Prisma.EvaluationParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationParameterPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvaluationParameterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationParameterPayload>[]
          }
          upsert: {
            args: Prisma.EvaluationParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationParameterPayload>
          }
          aggregate: {
            args: Prisma.EvaluationParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluationParameter>
          }
          groupBy: {
            args: Prisma.EvaluationParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationParameterCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationParameterCountAggregateOutputType> | number
          }
        }
      }
      Evaluation: {
        payload: Prisma.$EvaluationPayload<ExtArgs>
        fields: Prisma.EvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findFirst: {
            args: Prisma.EvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findMany: {
            args: Prisma.EvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          create: {
            args: Prisma.EvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          createMany: {
            args: Prisma.EvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          delete: {
            args: Prisma.EvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          update: {
            args: Prisma.EvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvaluationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          upsert: {
            args: Prisma.EvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          aggregate: {
            args: Prisma.EvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluation>
          }
          groupBy: {
            args: Prisma.EvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationCountAggregateOutputType> | number
          }
        }
      }
      EvaluationScore: {
        payload: Prisma.$EvaluationScorePayload<ExtArgs>
        fields: Prisma.EvaluationScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationScorePayload>
          }
          findFirst: {
            args: Prisma.EvaluationScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationScorePayload>
          }
          findMany: {
            args: Prisma.EvaluationScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationScorePayload>[]
          }
          create: {
            args: Prisma.EvaluationScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationScorePayload>
          }
          createMany: {
            args: Prisma.EvaluationScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationScorePayload>[]
          }
          delete: {
            args: Prisma.EvaluationScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationScorePayload>
          }
          update: {
            args: Prisma.EvaluationScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationScorePayload>
          }
          deleteMany: {
            args: Prisma.EvaluationScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvaluationScoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationScorePayload>[]
          }
          upsert: {
            args: Prisma.EvaluationScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationScorePayload>
          }
          aggregate: {
            args: Prisma.EvaluationScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluationScore>
          }
          groupBy: {
            args: Prisma.EvaluationScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationScoreCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationScoreCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      CkpScore: {
        payload: Prisma.$CkpScorePayload<ExtArgs>
        fields: Prisma.CkpScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CkpScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CkpScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CkpScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CkpScorePayload>
          }
          findFirst: {
            args: Prisma.CkpScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CkpScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CkpScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CkpScorePayload>
          }
          findMany: {
            args: Prisma.CkpScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CkpScorePayload>[]
          }
          create: {
            args: Prisma.CkpScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CkpScorePayload>
          }
          createMany: {
            args: Prisma.CkpScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CkpScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CkpScorePayload>[]
          }
          delete: {
            args: Prisma.CkpScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CkpScorePayload>
          }
          update: {
            args: Prisma.CkpScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CkpScorePayload>
          }
          deleteMany: {
            args: Prisma.CkpScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CkpScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CkpScoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CkpScorePayload>[]
          }
          upsert: {
            args: Prisma.CkpScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CkpScorePayload>
          }
          aggregate: {
            args: Prisma.CkpScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCkpScore>
          }
          groupBy: {
            args: Prisma.CkpScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<CkpScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.CkpScoreCountArgs<ExtArgs>
            result: $Utils.Optional<CkpScoreCountAggregateOutputType> | number
          }
        }
      }
      FinalEvaluation: {
        payload: Prisma.$FinalEvaluationPayload<ExtArgs>
        fields: Prisma.FinalEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinalEvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinalEvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalEvaluationPayload>
          }
          findFirst: {
            args: Prisma.FinalEvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinalEvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalEvaluationPayload>
          }
          findMany: {
            args: Prisma.FinalEvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalEvaluationPayload>[]
          }
          create: {
            args: Prisma.FinalEvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalEvaluationPayload>
          }
          createMany: {
            args: Prisma.FinalEvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinalEvaluationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalEvaluationPayload>[]
          }
          delete: {
            args: Prisma.FinalEvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalEvaluationPayload>
          }
          update: {
            args: Prisma.FinalEvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.FinalEvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinalEvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FinalEvaluationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalEvaluationPayload>[]
          }
          upsert: {
            args: Prisma.FinalEvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinalEvaluationPayload>
          }
          aggregate: {
            args: Prisma.FinalEvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinalEvaluation>
          }
          groupBy: {
            args: Prisma.FinalEvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinalEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinalEvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<FinalEvaluationCountAggregateOutputType> | number
          }
        }
      }
      AspekPenilaian: {
        payload: Prisma.$AspekPenilaianPayload<ExtArgs>
        fields: Prisma.AspekPenilaianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspekPenilaianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspekPenilaianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspekPenilaianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspekPenilaianPayload>
          }
          findFirst: {
            args: Prisma.AspekPenilaianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspekPenilaianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspekPenilaianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspekPenilaianPayload>
          }
          findMany: {
            args: Prisma.AspekPenilaianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspekPenilaianPayload>[]
          }
          create: {
            args: Prisma.AspekPenilaianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspekPenilaianPayload>
          }
          createMany: {
            args: Prisma.AspekPenilaianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AspekPenilaianCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspekPenilaianPayload>[]
          }
          delete: {
            args: Prisma.AspekPenilaianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspekPenilaianPayload>
          }
          update: {
            args: Prisma.AspekPenilaianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspekPenilaianPayload>
          }
          deleteMany: {
            args: Prisma.AspekPenilaianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspekPenilaianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AspekPenilaianUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspekPenilaianPayload>[]
          }
          upsert: {
            args: Prisma.AspekPenilaianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspekPenilaianPayload>
          }
          aggregate: {
            args: Prisma.AspekPenilaianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspekPenilaian>
          }
          groupBy: {
            args: Prisma.AspekPenilaianGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspekPenilaianGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspekPenilaianCountArgs<ExtArgs>
            result: $Utils.Optional<AspekPenilaianCountAggregateOutputType> | number
          }
        }
      }
      RentangNilai: {
        payload: Prisma.$RentangNilaiPayload<ExtArgs>
        fields: Prisma.RentangNilaiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RentangNilaiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentangNilaiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RentangNilaiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentangNilaiPayload>
          }
          findFirst: {
            args: Prisma.RentangNilaiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentangNilaiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RentangNilaiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentangNilaiPayload>
          }
          findMany: {
            args: Prisma.RentangNilaiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentangNilaiPayload>[]
          }
          create: {
            args: Prisma.RentangNilaiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentangNilaiPayload>
          }
          createMany: {
            args: Prisma.RentangNilaiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RentangNilaiCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentangNilaiPayload>[]
          }
          delete: {
            args: Prisma.RentangNilaiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentangNilaiPayload>
          }
          update: {
            args: Prisma.RentangNilaiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentangNilaiPayload>
          }
          deleteMany: {
            args: Prisma.RentangNilaiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RentangNilaiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RentangNilaiUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentangNilaiPayload>[]
          }
          upsert: {
            args: Prisma.RentangNilaiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentangNilaiPayload>
          }
          aggregate: {
            args: Prisma.RentangNilaiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRentangNilai>
          }
          groupBy: {
            args: Prisma.RentangNilaiGroupByArgs<ExtArgs>
            result: $Utils.Optional<RentangNilaiGroupByOutputType>[]
          }
          count: {
            args: Prisma.RentangNilaiCountArgs<ExtArgs>
            result: $Utils.Optional<RentangNilaiCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    period?: PeriodOmit
    evaluationParameter?: EvaluationParameterOmit
    evaluation?: EvaluationOmit
    evaluationScore?: EvaluationScoreOmit
    attendance?: AttendanceOmit
    ckpScore?: CkpScoreOmit
    finalEvaluation?: FinalEvaluationOmit
    aspekPenilaian?: AspekPenilaianOmit
    rentangNilai?: RentangNilaiOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    evaluationsGiven: number
    evaluationsReceived: number
    attendances: number
    ckpScores: number
    finalEvaluations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationsGiven?: boolean | UserCountOutputTypeCountEvaluationsGivenArgs
    evaluationsReceived?: boolean | UserCountOutputTypeCountEvaluationsReceivedArgs
    attendances?: boolean | UserCountOutputTypeCountAttendancesArgs
    ckpScores?: boolean | UserCountOutputTypeCountCkpScoresArgs
    finalEvaluations?: boolean | UserCountOutputTypeCountFinalEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEvaluationsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEvaluationsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCkpScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CkpScoreWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFinalEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalEvaluationWhereInput
  }


  /**
   * Count Type PeriodCountOutputType
   */

  export type PeriodCountOutputType = {
    evaluations: number
    attendances: number
    ckpScores: number
    finalEvaluations: number
  }

  export type PeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | PeriodCountOutputTypeCountEvaluationsArgs
    attendances?: boolean | PeriodCountOutputTypeCountAttendancesArgs
    ckpScores?: boolean | PeriodCountOutputTypeCountCkpScoresArgs
    finalEvaluations?: boolean | PeriodCountOutputTypeCountFinalEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * PeriodCountOutputType without action
   */
  export type PeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodCountOutputType
     */
    select?: PeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PeriodCountOutputType without action
   */
  export type PeriodCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }

  /**
   * PeriodCountOutputType without action
   */
  export type PeriodCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * PeriodCountOutputType without action
   */
  export type PeriodCountOutputTypeCountCkpScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CkpScoreWhereInput
  }

  /**
   * PeriodCountOutputType without action
   */
  export type PeriodCountOutputTypeCountFinalEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalEvaluationWhereInput
  }


  /**
   * Count Type EvaluationParameterCountOutputType
   */

  export type EvaluationParameterCountOutputType = {
    evaluationScores: number
  }

  export type EvaluationParameterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationScores?: boolean | EvaluationParameterCountOutputTypeCountEvaluationScoresArgs
  }

  // Custom InputTypes
  /**
   * EvaluationParameterCountOutputType without action
   */
  export type EvaluationParameterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameterCountOutputType
     */
    select?: EvaluationParameterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvaluationParameterCountOutputType without action
   */
  export type EvaluationParameterCountOutputTypeCountEvaluationScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationScoreWhereInput
  }


  /**
   * Count Type EvaluationCountOutputType
   */

  export type EvaluationCountOutputType = {
    scores: number
  }

  export type EvaluationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scores?: boolean | EvaluationCountOutputTypeCountScoresArgs
  }

  // Custom InputTypes
  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationCountOutputType
     */
    select?: EvaluationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeCountScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationScoreWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    nip: string | null
    nama: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    jenisKelamin: $Enums.Gender | null
    tanggalLahir: Date | null
    alamat: string | null
    mobilePhone: string | null
    pendidikanTerakhir: string | null
    jabatan: string | null
    golongan: string | null
    status: string | null
    instansi: string | null
    kantor: string | null
    username: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    nip: string | null
    nama: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    jenisKelamin: $Enums.Gender | null
    tanggalLahir: Date | null
    alamat: string | null
    mobilePhone: string | null
    pendidikanTerakhir: string | null
    jabatan: string | null
    golongan: string | null
    status: string | null
    instansi: string | null
    kantor: string | null
    username: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    nip: number
    nama: number
    email: number
    password: number
    role: number
    jenisKelamin: number
    tanggalLahir: number
    alamat: number
    mobilePhone: number
    pendidikanTerakhir: number
    jabatan: number
    golongan: number
    status: number
    instansi: number
    kantor: number
    username: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    nip?: true
    nama?: true
    email?: true
    password?: true
    role?: true
    jenisKelamin?: true
    tanggalLahir?: true
    alamat?: true
    mobilePhone?: true
    pendidikanTerakhir?: true
    jabatan?: true
    golongan?: true
    status?: true
    instansi?: true
    kantor?: true
    username?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    nip?: true
    nama?: true
    email?: true
    password?: true
    role?: true
    jenisKelamin?: true
    tanggalLahir?: true
    alamat?: true
    mobilePhone?: true
    pendidikanTerakhir?: true
    jabatan?: true
    golongan?: true
    status?: true
    instansi?: true
    kantor?: true
    username?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    nip?: true
    nama?: true
    email?: true
    password?: true
    role?: true
    jenisKelamin?: true
    tanggalLahir?: true
    alamat?: true
    mobilePhone?: true
    pendidikanTerakhir?: true
    jabatan?: true
    golongan?: true
    status?: true
    instansi?: true
    kantor?: true
    username?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    nip: string
    nama: string
    email: string | null
    password: string
    role: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir: Date | null
    alamat: string | null
    mobilePhone: string | null
    pendidikanTerakhir: string | null
    jabatan: string | null
    golongan: string | null
    status: string
    instansi: string | null
    kantor: string | null
    username: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nip?: boolean
    nama?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    jenisKelamin?: boolean
    tanggalLahir?: boolean
    alamat?: boolean
    mobilePhone?: boolean
    pendidikanTerakhir?: boolean
    jabatan?: boolean
    golongan?: boolean
    status?: boolean
    instansi?: boolean
    kantor?: boolean
    username?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluationsGiven?: boolean | User$evaluationsGivenArgs<ExtArgs>
    evaluationsReceived?: boolean | User$evaluationsReceivedArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    ckpScores?: boolean | User$ckpScoresArgs<ExtArgs>
    finalEvaluations?: boolean | User$finalEvaluationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nip?: boolean
    nama?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    jenisKelamin?: boolean
    tanggalLahir?: boolean
    alamat?: boolean
    mobilePhone?: boolean
    pendidikanTerakhir?: boolean
    jabatan?: boolean
    golongan?: boolean
    status?: boolean
    instansi?: boolean
    kantor?: boolean
    username?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nip?: boolean
    nama?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    jenisKelamin?: boolean
    tanggalLahir?: boolean
    alamat?: boolean
    mobilePhone?: boolean
    pendidikanTerakhir?: boolean
    jabatan?: boolean
    golongan?: boolean
    status?: boolean
    instansi?: boolean
    kantor?: boolean
    username?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    nip?: boolean
    nama?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    jenisKelamin?: boolean
    tanggalLahir?: boolean
    alamat?: boolean
    mobilePhone?: boolean
    pendidikanTerakhir?: boolean
    jabatan?: boolean
    golongan?: boolean
    status?: boolean
    instansi?: boolean
    kantor?: boolean
    username?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nip" | "nama" | "email" | "password" | "role" | "jenisKelamin" | "tanggalLahir" | "alamat" | "mobilePhone" | "pendidikanTerakhir" | "jabatan" | "golongan" | "status" | "instansi" | "kantor" | "username" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationsGiven?: boolean | User$evaluationsGivenArgs<ExtArgs>
    evaluationsReceived?: boolean | User$evaluationsReceivedArgs<ExtArgs>
    attendances?: boolean | User$attendancesArgs<ExtArgs>
    ckpScores?: boolean | User$ckpScoresArgs<ExtArgs>
    finalEvaluations?: boolean | User$finalEvaluationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      evaluationsGiven: Prisma.$EvaluationPayload<ExtArgs>[]
      evaluationsReceived: Prisma.$EvaluationPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      ckpScores: Prisma.$CkpScorePayload<ExtArgs>[]
      finalEvaluations: Prisma.$FinalEvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nip: string
      nama: string
      email: string | null
      password: string
      role: $Enums.Role
      jenisKelamin: $Enums.Gender
      tanggalLahir: Date | null
      alamat: string | null
      mobilePhone: string | null
      pendidikanTerakhir: string | null
      jabatan: string | null
      golongan: string | null
      status: string
      instansi: string | null
      kantor: string | null
      username: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluationsGiven<T extends User$evaluationsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$evaluationsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evaluationsReceived<T extends User$evaluationsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$evaluationsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends User$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, User$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ckpScores<T extends User$ckpScoresArgs<ExtArgs> = {}>(args?: Subset<T, User$ckpScoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    finalEvaluations<T extends User$finalEvaluationsArgs<ExtArgs> = {}>(args?: Subset<T, User$finalEvaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly nip: FieldRef<"User", 'String'>
    readonly nama: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly jenisKelamin: FieldRef<"User", 'Gender'>
    readonly tanggalLahir: FieldRef<"User", 'DateTime'>
    readonly alamat: FieldRef<"User", 'String'>
    readonly mobilePhone: FieldRef<"User", 'String'>
    readonly pendidikanTerakhir: FieldRef<"User", 'String'>
    readonly jabatan: FieldRef<"User", 'String'>
    readonly golongan: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly instansi: FieldRef<"User", 'String'>
    readonly kantor: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.evaluationsGiven
   */
  export type User$evaluationsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * User.evaluationsReceived
   */
  export type User$evaluationsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * User.attendances
   */
  export type User$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * User.ckpScores
   */
  export type User$ckpScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreInclude<ExtArgs> | null
    where?: CkpScoreWhereInput
    orderBy?: CkpScoreOrderByWithRelationInput | CkpScoreOrderByWithRelationInput[]
    cursor?: CkpScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CkpScoreScalarFieldEnum | CkpScoreScalarFieldEnum[]
  }

  /**
   * User.finalEvaluations
   */
  export type User$finalEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationInclude<ExtArgs> | null
    where?: FinalEvaluationWhereInput
    orderBy?: FinalEvaluationOrderByWithRelationInput | FinalEvaluationOrderByWithRelationInput[]
    cursor?: FinalEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinalEvaluationScalarFieldEnum | FinalEvaluationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Period
   */

  export type AggregatePeriod = {
    _count: PeriodCountAggregateOutputType | null
    _avg: PeriodAvgAggregateOutputType | null
    _sum: PeriodSumAggregateOutputType | null
    _min: PeriodMinAggregateOutputType | null
    _max: PeriodMaxAggregateOutputType | null
  }

  export type PeriodAvgAggregateOutputType = {
    tahun: number | null
    bulan: number | null
    noPeriode: number | null
  }

  export type PeriodSumAggregateOutputType = {
    tahun: number | null
    bulan: number | null
    noPeriode: number | null
  }

  export type PeriodMinAggregateOutputType = {
    id: string | null
    tahun: number | null
    bulan: number | null
    namaPeriode: string | null
    noPeriode: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PeriodMaxAggregateOutputType = {
    id: string | null
    tahun: number | null
    bulan: number | null
    namaPeriode: string | null
    noPeriode: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PeriodCountAggregateOutputType = {
    id: number
    tahun: number
    bulan: number
    namaPeriode: number
    noPeriode: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PeriodAvgAggregateInputType = {
    tahun?: true
    bulan?: true
    noPeriode?: true
  }

  export type PeriodSumAggregateInputType = {
    tahun?: true
    bulan?: true
    noPeriode?: true
  }

  export type PeriodMinAggregateInputType = {
    id?: true
    tahun?: true
    bulan?: true
    namaPeriode?: true
    noPeriode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PeriodMaxAggregateInputType = {
    id?: true
    tahun?: true
    bulan?: true
    namaPeriode?: true
    noPeriode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PeriodCountAggregateInputType = {
    id?: true
    tahun?: true
    bulan?: true
    namaPeriode?: true
    noPeriode?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Period to aggregate.
     */
    where?: PeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Periods to fetch.
     */
    orderBy?: PeriodOrderByWithRelationInput | PeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Periods
    **/
    _count?: true | PeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PeriodMaxAggregateInputType
  }

  export type GetPeriodAggregateType<T extends PeriodAggregateArgs> = {
        [P in keyof T & keyof AggregatePeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeriod[P]>
      : GetScalarType<T[P], AggregatePeriod[P]>
  }




  export type PeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PeriodWhereInput
    orderBy?: PeriodOrderByWithAggregationInput | PeriodOrderByWithAggregationInput[]
    by: PeriodScalarFieldEnum[] | PeriodScalarFieldEnum
    having?: PeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PeriodCountAggregateInputType | true
    _avg?: PeriodAvgAggregateInputType
    _sum?: PeriodSumAggregateInputType
    _min?: PeriodMinAggregateInputType
    _max?: PeriodMaxAggregateInputType
  }

  export type PeriodGroupByOutputType = {
    id: string
    tahun: number
    bulan: number
    namaPeriode: string
    noPeriode: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PeriodCountAggregateOutputType | null
    _avg: PeriodAvgAggregateOutputType | null
    _sum: PeriodSumAggregateOutputType | null
    _min: PeriodMinAggregateOutputType | null
    _max: PeriodMaxAggregateOutputType | null
  }

  type GetPeriodGroupByPayload<T extends PeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PeriodGroupByOutputType[P]>
            : GetScalarType<T[P], PeriodGroupByOutputType[P]>
        }
      >
    >


  export type PeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tahun?: boolean
    bulan?: boolean
    namaPeriode?: boolean
    noPeriode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluations?: boolean | Period$evaluationsArgs<ExtArgs>
    attendances?: boolean | Period$attendancesArgs<ExtArgs>
    ckpScores?: boolean | Period$ckpScoresArgs<ExtArgs>
    finalEvaluations?: boolean | Period$finalEvaluationsArgs<ExtArgs>
    _count?: boolean | PeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["period"]>

  export type PeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tahun?: boolean
    bulan?: boolean
    namaPeriode?: boolean
    noPeriode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["period"]>

  export type PeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tahun?: boolean
    bulan?: boolean
    namaPeriode?: boolean
    noPeriode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["period"]>

  export type PeriodSelectScalar = {
    id?: boolean
    tahun?: boolean
    bulan?: boolean
    namaPeriode?: boolean
    noPeriode?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tahun" | "bulan" | "namaPeriode" | "noPeriode" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["period"]>
  export type PeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | Period$evaluationsArgs<ExtArgs>
    attendances?: boolean | Period$attendancesArgs<ExtArgs>
    ckpScores?: boolean | Period$ckpScoresArgs<ExtArgs>
    finalEvaluations?: boolean | Period$finalEvaluationsArgs<ExtArgs>
    _count?: boolean | PeriodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PeriodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Period"
    objects: {
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      ckpScores: Prisma.$CkpScorePayload<ExtArgs>[]
      finalEvaluations: Prisma.$FinalEvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tahun: number
      bulan: number
      namaPeriode: string
      noPeriode: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["period"]>
    composites: {}
  }

  type PeriodGetPayload<S extends boolean | null | undefined | PeriodDefaultArgs> = $Result.GetResult<Prisma.$PeriodPayload, S>

  type PeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PeriodCountAggregateInputType | true
    }

  export interface PeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Period'], meta: { name: 'Period' } }
    /**
     * Find zero or one Period that matches the filter.
     * @param {PeriodFindUniqueArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PeriodFindUniqueArgs>(args: SelectSubset<T, PeriodFindUniqueArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Period that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PeriodFindUniqueOrThrowArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, PeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Period that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodFindFirstArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PeriodFindFirstArgs>(args?: SelectSubset<T, PeriodFindFirstArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Period that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodFindFirstOrThrowArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, PeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Periods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Periods
     * const periods = await prisma.period.findMany()
     * 
     * // Get first 10 Periods
     * const periods = await prisma.period.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const periodWithIdOnly = await prisma.period.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PeriodFindManyArgs>(args?: SelectSubset<T, PeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Period.
     * @param {PeriodCreateArgs} args - Arguments to create a Period.
     * @example
     * // Create one Period
     * const Period = await prisma.period.create({
     *   data: {
     *     // ... data to create a Period
     *   }
     * })
     * 
     */
    create<T extends PeriodCreateArgs>(args: SelectSubset<T, PeriodCreateArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Periods.
     * @param {PeriodCreateManyArgs} args - Arguments to create many Periods.
     * @example
     * // Create many Periods
     * const period = await prisma.period.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PeriodCreateManyArgs>(args?: SelectSubset<T, PeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Periods and returns the data saved in the database.
     * @param {PeriodCreateManyAndReturnArgs} args - Arguments to create many Periods.
     * @example
     * // Create many Periods
     * const period = await prisma.period.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Periods and only return the `id`
     * const periodWithIdOnly = await prisma.period.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, PeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Period.
     * @param {PeriodDeleteArgs} args - Arguments to delete one Period.
     * @example
     * // Delete one Period
     * const Period = await prisma.period.delete({
     *   where: {
     *     // ... filter to delete one Period
     *   }
     * })
     * 
     */
    delete<T extends PeriodDeleteArgs>(args: SelectSubset<T, PeriodDeleteArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Period.
     * @param {PeriodUpdateArgs} args - Arguments to update one Period.
     * @example
     * // Update one Period
     * const period = await prisma.period.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PeriodUpdateArgs>(args: SelectSubset<T, PeriodUpdateArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Periods.
     * @param {PeriodDeleteManyArgs} args - Arguments to filter Periods to delete.
     * @example
     * // Delete a few Periods
     * const { count } = await prisma.period.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PeriodDeleteManyArgs>(args?: SelectSubset<T, PeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Periods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Periods
     * const period = await prisma.period.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PeriodUpdateManyArgs>(args: SelectSubset<T, PeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Periods and returns the data updated in the database.
     * @param {PeriodUpdateManyAndReturnArgs} args - Arguments to update many Periods.
     * @example
     * // Update many Periods
     * const period = await prisma.period.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Periods and only return the `id`
     * const periodWithIdOnly = await prisma.period.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, PeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Period.
     * @param {PeriodUpsertArgs} args - Arguments to update or create a Period.
     * @example
     * // Update or create a Period
     * const period = await prisma.period.upsert({
     *   create: {
     *     // ... data to create a Period
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Period we want to update
     *   }
     * })
     */
    upsert<T extends PeriodUpsertArgs>(args: SelectSubset<T, PeriodUpsertArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Periods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodCountArgs} args - Arguments to filter Periods to count.
     * @example
     * // Count the number of Periods
     * const count = await prisma.period.count({
     *   where: {
     *     // ... the filter for the Periods we want to count
     *   }
     * })
    **/
    count<T extends PeriodCountArgs>(
      args?: Subset<T, PeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Period.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeriodAggregateArgs>(args: Subset<T, PeriodAggregateArgs>): Prisma.PrismaPromise<GetPeriodAggregateType<T>>

    /**
     * Group by Period.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PeriodGroupByArgs['orderBy'] }
        : { orderBy?: PeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Period model
   */
  readonly fields: PeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Period.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluations<T extends Period$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Period$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends Period$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Period$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ckpScores<T extends Period$ckpScoresArgs<ExtArgs> = {}>(args?: Subset<T, Period$ckpScoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    finalEvaluations<T extends Period$finalEvaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Period$finalEvaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Period model
   */
  interface PeriodFieldRefs {
    readonly id: FieldRef<"Period", 'String'>
    readonly tahun: FieldRef<"Period", 'Int'>
    readonly bulan: FieldRef<"Period", 'Int'>
    readonly namaPeriode: FieldRef<"Period", 'String'>
    readonly noPeriode: FieldRef<"Period", 'Int'>
    readonly isActive: FieldRef<"Period", 'Boolean'>
    readonly createdAt: FieldRef<"Period", 'DateTime'>
    readonly updatedAt: FieldRef<"Period", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Period findUnique
   */
  export type PeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * Filter, which Period to fetch.
     */
    where: PeriodWhereUniqueInput
  }

  /**
   * Period findUniqueOrThrow
   */
  export type PeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * Filter, which Period to fetch.
     */
    where: PeriodWhereUniqueInput
  }

  /**
   * Period findFirst
   */
  export type PeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * Filter, which Period to fetch.
     */
    where?: PeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Periods to fetch.
     */
    orderBy?: PeriodOrderByWithRelationInput | PeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Periods.
     */
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Periods.
     */
    distinct?: PeriodScalarFieldEnum | PeriodScalarFieldEnum[]
  }

  /**
   * Period findFirstOrThrow
   */
  export type PeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * Filter, which Period to fetch.
     */
    where?: PeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Periods to fetch.
     */
    orderBy?: PeriodOrderByWithRelationInput | PeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Periods.
     */
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Periods.
     */
    distinct?: PeriodScalarFieldEnum | PeriodScalarFieldEnum[]
  }

  /**
   * Period findMany
   */
  export type PeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * Filter, which Periods to fetch.
     */
    where?: PeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Periods to fetch.
     */
    orderBy?: PeriodOrderByWithRelationInput | PeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Periods.
     */
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
     */
    skip?: number
    distinct?: PeriodScalarFieldEnum | PeriodScalarFieldEnum[]
  }

  /**
   * Period create
   */
  export type PeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a Period.
     */
    data: XOR<PeriodCreateInput, PeriodUncheckedCreateInput>
  }

  /**
   * Period createMany
   */
  export type PeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Periods.
     */
    data: PeriodCreateManyInput | PeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Period createManyAndReturn
   */
  export type PeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * The data used to create many Periods.
     */
    data: PeriodCreateManyInput | PeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Period update
   */
  export type PeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a Period.
     */
    data: XOR<PeriodUpdateInput, PeriodUncheckedUpdateInput>
    /**
     * Choose, which Period to update.
     */
    where: PeriodWhereUniqueInput
  }

  /**
   * Period updateMany
   */
  export type PeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Periods.
     */
    data: XOR<PeriodUpdateManyMutationInput, PeriodUncheckedUpdateManyInput>
    /**
     * Filter which Periods to update
     */
    where?: PeriodWhereInput
    /**
     * Limit how many Periods to update.
     */
    limit?: number
  }

  /**
   * Period updateManyAndReturn
   */
  export type PeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * The data used to update Periods.
     */
    data: XOR<PeriodUpdateManyMutationInput, PeriodUncheckedUpdateManyInput>
    /**
     * Filter which Periods to update
     */
    where?: PeriodWhereInput
    /**
     * Limit how many Periods to update.
     */
    limit?: number
  }

  /**
   * Period upsert
   */
  export type PeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the Period to update in case it exists.
     */
    where: PeriodWhereUniqueInput
    /**
     * In case the Period found by the `where` argument doesn't exist, create a new Period with this data.
     */
    create: XOR<PeriodCreateInput, PeriodUncheckedCreateInput>
    /**
     * In case the Period was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PeriodUpdateInput, PeriodUncheckedUpdateInput>
  }

  /**
   * Period delete
   */
  export type PeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * Filter which Period to delete.
     */
    where: PeriodWhereUniqueInput
  }

  /**
   * Period deleteMany
   */
  export type PeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Periods to delete
     */
    where?: PeriodWhereInput
    /**
     * Limit how many Periods to delete.
     */
    limit?: number
  }

  /**
   * Period.evaluations
   */
  export type Period$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Period.attendances
   */
  export type Period$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Period.ckpScores
   */
  export type Period$ckpScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreInclude<ExtArgs> | null
    where?: CkpScoreWhereInput
    orderBy?: CkpScoreOrderByWithRelationInput | CkpScoreOrderByWithRelationInput[]
    cursor?: CkpScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CkpScoreScalarFieldEnum | CkpScoreScalarFieldEnum[]
  }

  /**
   * Period.finalEvaluations
   */
  export type Period$finalEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationInclude<ExtArgs> | null
    where?: FinalEvaluationWhereInput
    orderBy?: FinalEvaluationOrderByWithRelationInput | FinalEvaluationOrderByWithRelationInput[]
    cursor?: FinalEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinalEvaluationScalarFieldEnum | FinalEvaluationScalarFieldEnum[]
  }

  /**
   * Period without action
   */
  export type PeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
  }


  /**
   * Model EvaluationParameter
   */

  export type AggregateEvaluationParameter = {
    _count: EvaluationParameterCountAggregateOutputType | null
    _avg: EvaluationParameterAvgAggregateOutputType | null
    _sum: EvaluationParameterSumAggregateOutputType | null
    _min: EvaluationParameterMinAggregateOutputType | null
    _max: EvaluationParameterMaxAggregateOutputType | null
  }

  export type EvaluationParameterAvgAggregateOutputType = {
    urutan: number | null
  }

  export type EvaluationParameterSumAggregateOutputType = {
    urutan: number | null
  }

  export type EvaluationParameterMinAggregateOutputType = {
    id: string | null
    namaParameter: string | null
    deskripsi: string | null
    kategori: string | null
    urutan: number | null
    createdAt: Date | null
  }

  export type EvaluationParameterMaxAggregateOutputType = {
    id: string | null
    namaParameter: string | null
    deskripsi: string | null
    kategori: string | null
    urutan: number | null
    createdAt: Date | null
  }

  export type EvaluationParameterCountAggregateOutputType = {
    id: number
    namaParameter: number
    deskripsi: number
    kategori: number
    urutan: number
    createdAt: number
    _all: number
  }


  export type EvaluationParameterAvgAggregateInputType = {
    urutan?: true
  }

  export type EvaluationParameterSumAggregateInputType = {
    urutan?: true
  }

  export type EvaluationParameterMinAggregateInputType = {
    id?: true
    namaParameter?: true
    deskripsi?: true
    kategori?: true
    urutan?: true
    createdAt?: true
  }

  export type EvaluationParameterMaxAggregateInputType = {
    id?: true
    namaParameter?: true
    deskripsi?: true
    kategori?: true
    urutan?: true
    createdAt?: true
  }

  export type EvaluationParameterCountAggregateInputType = {
    id?: true
    namaParameter?: true
    deskripsi?: true
    kategori?: true
    urutan?: true
    createdAt?: true
    _all?: true
  }

  export type EvaluationParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationParameter to aggregate.
     */
    where?: EvaluationParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationParameters to fetch.
     */
    orderBy?: EvaluationParameterOrderByWithRelationInput | EvaluationParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaluationParameters
    **/
    _count?: true | EvaluationParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationParameterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationParameterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationParameterMaxAggregateInputType
  }

  export type GetEvaluationParameterAggregateType<T extends EvaluationParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluationParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluationParameter[P]>
      : GetScalarType<T[P], AggregateEvaluationParameter[P]>
  }




  export type EvaluationParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationParameterWhereInput
    orderBy?: EvaluationParameterOrderByWithAggregationInput | EvaluationParameterOrderByWithAggregationInput[]
    by: EvaluationParameterScalarFieldEnum[] | EvaluationParameterScalarFieldEnum
    having?: EvaluationParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationParameterCountAggregateInputType | true
    _avg?: EvaluationParameterAvgAggregateInputType
    _sum?: EvaluationParameterSumAggregateInputType
    _min?: EvaluationParameterMinAggregateInputType
    _max?: EvaluationParameterMaxAggregateInputType
  }

  export type EvaluationParameterGroupByOutputType = {
    id: string
    namaParameter: string
    deskripsi: string | null
    kategori: string
    urutan: number
    createdAt: Date
    _count: EvaluationParameterCountAggregateOutputType | null
    _avg: EvaluationParameterAvgAggregateOutputType | null
    _sum: EvaluationParameterSumAggregateOutputType | null
    _min: EvaluationParameterMinAggregateOutputType | null
    _max: EvaluationParameterMaxAggregateOutputType | null
  }

  type GetEvaluationParameterGroupByPayload<T extends EvaluationParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationParameterGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationParameterGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namaParameter?: boolean
    deskripsi?: boolean
    kategori?: boolean
    urutan?: boolean
    createdAt?: boolean
    evaluationScores?: boolean | EvaluationParameter$evaluationScoresArgs<ExtArgs>
    _count?: boolean | EvaluationParameterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationParameter"]>

  export type EvaluationParameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namaParameter?: boolean
    deskripsi?: boolean
    kategori?: boolean
    urutan?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["evaluationParameter"]>

  export type EvaluationParameterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namaParameter?: boolean
    deskripsi?: boolean
    kategori?: boolean
    urutan?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["evaluationParameter"]>

  export type EvaluationParameterSelectScalar = {
    id?: boolean
    namaParameter?: boolean
    deskripsi?: boolean
    kategori?: boolean
    urutan?: boolean
    createdAt?: boolean
  }

  export type EvaluationParameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "namaParameter" | "deskripsi" | "kategori" | "urutan" | "createdAt", ExtArgs["result"]["evaluationParameter"]>
  export type EvaluationParameterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluationScores?: boolean | EvaluationParameter$evaluationScoresArgs<ExtArgs>
    _count?: boolean | EvaluationParameterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EvaluationParameterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EvaluationParameterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EvaluationParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaluationParameter"
    objects: {
      evaluationScores: Prisma.$EvaluationScorePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      namaParameter: string
      deskripsi: string | null
      kategori: string
      urutan: number
      createdAt: Date
    }, ExtArgs["result"]["evaluationParameter"]>
    composites: {}
  }

  type EvaluationParameterGetPayload<S extends boolean | null | undefined | EvaluationParameterDefaultArgs> = $Result.GetResult<Prisma.$EvaluationParameterPayload, S>

  type EvaluationParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvaluationParameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvaluationParameterCountAggregateInputType | true
    }

  export interface EvaluationParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaluationParameter'], meta: { name: 'EvaluationParameter' } }
    /**
     * Find zero or one EvaluationParameter that matches the filter.
     * @param {EvaluationParameterFindUniqueArgs} args - Arguments to find a EvaluationParameter
     * @example
     * // Get one EvaluationParameter
     * const evaluationParameter = await prisma.evaluationParameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationParameterFindUniqueArgs>(args: SelectSubset<T, EvaluationParameterFindUniqueArgs<ExtArgs>>): Prisma__EvaluationParameterClient<$Result.GetResult<Prisma.$EvaluationParameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EvaluationParameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvaluationParameterFindUniqueOrThrowArgs} args - Arguments to find a EvaluationParameter
     * @example
     * // Get one EvaluationParameter
     * const evaluationParameter = await prisma.evaluationParameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationParameterClient<$Result.GetResult<Prisma.$EvaluationParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvaluationParameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationParameterFindFirstArgs} args - Arguments to find a EvaluationParameter
     * @example
     * // Get one EvaluationParameter
     * const evaluationParameter = await prisma.evaluationParameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationParameterFindFirstArgs>(args?: SelectSubset<T, EvaluationParameterFindFirstArgs<ExtArgs>>): Prisma__EvaluationParameterClient<$Result.GetResult<Prisma.$EvaluationParameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvaluationParameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationParameterFindFirstOrThrowArgs} args - Arguments to find a EvaluationParameter
     * @example
     * // Get one EvaluationParameter
     * const evaluationParameter = await prisma.evaluationParameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationParameterClient<$Result.GetResult<Prisma.$EvaluationParameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EvaluationParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaluationParameters
     * const evaluationParameters = await prisma.evaluationParameter.findMany()
     * 
     * // Get first 10 EvaluationParameters
     * const evaluationParameters = await prisma.evaluationParameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationParameterWithIdOnly = await prisma.evaluationParameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationParameterFindManyArgs>(args?: SelectSubset<T, EvaluationParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EvaluationParameter.
     * @param {EvaluationParameterCreateArgs} args - Arguments to create a EvaluationParameter.
     * @example
     * // Create one EvaluationParameter
     * const EvaluationParameter = await prisma.evaluationParameter.create({
     *   data: {
     *     // ... data to create a EvaluationParameter
     *   }
     * })
     * 
     */
    create<T extends EvaluationParameterCreateArgs>(args: SelectSubset<T, EvaluationParameterCreateArgs<ExtArgs>>): Prisma__EvaluationParameterClient<$Result.GetResult<Prisma.$EvaluationParameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EvaluationParameters.
     * @param {EvaluationParameterCreateManyArgs} args - Arguments to create many EvaluationParameters.
     * @example
     * // Create many EvaluationParameters
     * const evaluationParameter = await prisma.evaluationParameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationParameterCreateManyArgs>(args?: SelectSubset<T, EvaluationParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvaluationParameters and returns the data saved in the database.
     * @param {EvaluationParameterCreateManyAndReturnArgs} args - Arguments to create many EvaluationParameters.
     * @example
     * // Create many EvaluationParameters
     * const evaluationParameter = await prisma.evaluationParameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvaluationParameters and only return the `id`
     * const evaluationParameterWithIdOnly = await prisma.evaluationParameter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluationParameterCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluationParameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationParameterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EvaluationParameter.
     * @param {EvaluationParameterDeleteArgs} args - Arguments to delete one EvaluationParameter.
     * @example
     * // Delete one EvaluationParameter
     * const EvaluationParameter = await prisma.evaluationParameter.delete({
     *   where: {
     *     // ... filter to delete one EvaluationParameter
     *   }
     * })
     * 
     */
    delete<T extends EvaluationParameterDeleteArgs>(args: SelectSubset<T, EvaluationParameterDeleteArgs<ExtArgs>>): Prisma__EvaluationParameterClient<$Result.GetResult<Prisma.$EvaluationParameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EvaluationParameter.
     * @param {EvaluationParameterUpdateArgs} args - Arguments to update one EvaluationParameter.
     * @example
     * // Update one EvaluationParameter
     * const evaluationParameter = await prisma.evaluationParameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationParameterUpdateArgs>(args: SelectSubset<T, EvaluationParameterUpdateArgs<ExtArgs>>): Prisma__EvaluationParameterClient<$Result.GetResult<Prisma.$EvaluationParameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EvaluationParameters.
     * @param {EvaluationParameterDeleteManyArgs} args - Arguments to filter EvaluationParameters to delete.
     * @example
     * // Delete a few EvaluationParameters
     * const { count } = await prisma.evaluationParameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationParameterDeleteManyArgs>(args?: SelectSubset<T, EvaluationParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaluationParameters
     * const evaluationParameter = await prisma.evaluationParameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationParameterUpdateManyArgs>(args: SelectSubset<T, EvaluationParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationParameters and returns the data updated in the database.
     * @param {EvaluationParameterUpdateManyAndReturnArgs} args - Arguments to update many EvaluationParameters.
     * @example
     * // Update many EvaluationParameters
     * const evaluationParameter = await prisma.evaluationParameter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EvaluationParameters and only return the `id`
     * const evaluationParameterWithIdOnly = await prisma.evaluationParameter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvaluationParameterUpdateManyAndReturnArgs>(args: SelectSubset<T, EvaluationParameterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationParameterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EvaluationParameter.
     * @param {EvaluationParameterUpsertArgs} args - Arguments to update or create a EvaluationParameter.
     * @example
     * // Update or create a EvaluationParameter
     * const evaluationParameter = await prisma.evaluationParameter.upsert({
     *   create: {
     *     // ... data to create a EvaluationParameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaluationParameter we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationParameterUpsertArgs>(args: SelectSubset<T, EvaluationParameterUpsertArgs<ExtArgs>>): Prisma__EvaluationParameterClient<$Result.GetResult<Prisma.$EvaluationParameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EvaluationParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationParameterCountArgs} args - Arguments to filter EvaluationParameters to count.
     * @example
     * // Count the number of EvaluationParameters
     * const count = await prisma.evaluationParameter.count({
     *   where: {
     *     // ... the filter for the EvaluationParameters we want to count
     *   }
     * })
    **/
    count<T extends EvaluationParameterCountArgs>(
      args?: Subset<T, EvaluationParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaluationParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationParameterAggregateArgs>(args: Subset<T, EvaluationParameterAggregateArgs>): Prisma.PrismaPromise<GetEvaluationParameterAggregateType<T>>

    /**
     * Group by EvaluationParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationParameterGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaluationParameter model
   */
  readonly fields: EvaluationParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaluationParameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluationScores<T extends EvaluationParameter$evaluationScoresArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationParameter$evaluationScoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvaluationParameter model
   */
  interface EvaluationParameterFieldRefs {
    readonly id: FieldRef<"EvaluationParameter", 'String'>
    readonly namaParameter: FieldRef<"EvaluationParameter", 'String'>
    readonly deskripsi: FieldRef<"EvaluationParameter", 'String'>
    readonly kategori: FieldRef<"EvaluationParameter", 'String'>
    readonly urutan: FieldRef<"EvaluationParameter", 'Int'>
    readonly createdAt: FieldRef<"EvaluationParameter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvaluationParameter findUnique
   */
  export type EvaluationParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameter
     */
    select?: EvaluationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationParameter
     */
    omit?: EvaluationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationParameterInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationParameter to fetch.
     */
    where: EvaluationParameterWhereUniqueInput
  }

  /**
   * EvaluationParameter findUniqueOrThrow
   */
  export type EvaluationParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameter
     */
    select?: EvaluationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationParameter
     */
    omit?: EvaluationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationParameterInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationParameter to fetch.
     */
    where: EvaluationParameterWhereUniqueInput
  }

  /**
   * EvaluationParameter findFirst
   */
  export type EvaluationParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameter
     */
    select?: EvaluationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationParameter
     */
    omit?: EvaluationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationParameterInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationParameter to fetch.
     */
    where?: EvaluationParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationParameters to fetch.
     */
    orderBy?: EvaluationParameterOrderByWithRelationInput | EvaluationParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationParameters.
     */
    cursor?: EvaluationParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationParameters.
     */
    distinct?: EvaluationParameterScalarFieldEnum | EvaluationParameterScalarFieldEnum[]
  }

  /**
   * EvaluationParameter findFirstOrThrow
   */
  export type EvaluationParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameter
     */
    select?: EvaluationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationParameter
     */
    omit?: EvaluationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationParameterInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationParameter to fetch.
     */
    where?: EvaluationParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationParameters to fetch.
     */
    orderBy?: EvaluationParameterOrderByWithRelationInput | EvaluationParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationParameters.
     */
    cursor?: EvaluationParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationParameters.
     */
    distinct?: EvaluationParameterScalarFieldEnum | EvaluationParameterScalarFieldEnum[]
  }

  /**
   * EvaluationParameter findMany
   */
  export type EvaluationParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameter
     */
    select?: EvaluationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationParameter
     */
    omit?: EvaluationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationParameterInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationParameters to fetch.
     */
    where?: EvaluationParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationParameters to fetch.
     */
    orderBy?: EvaluationParameterOrderByWithRelationInput | EvaluationParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaluationParameters.
     */
    cursor?: EvaluationParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationParameters.
     */
    skip?: number
    distinct?: EvaluationParameterScalarFieldEnum | EvaluationParameterScalarFieldEnum[]
  }

  /**
   * EvaluationParameter create
   */
  export type EvaluationParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameter
     */
    select?: EvaluationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationParameter
     */
    omit?: EvaluationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationParameterInclude<ExtArgs> | null
    /**
     * The data needed to create a EvaluationParameter.
     */
    data: XOR<EvaluationParameterCreateInput, EvaluationParameterUncheckedCreateInput>
  }

  /**
   * EvaluationParameter createMany
   */
  export type EvaluationParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaluationParameters.
     */
    data: EvaluationParameterCreateManyInput | EvaluationParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvaluationParameter createManyAndReturn
   */
  export type EvaluationParameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameter
     */
    select?: EvaluationParameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationParameter
     */
    omit?: EvaluationParameterOmit<ExtArgs> | null
    /**
     * The data used to create many EvaluationParameters.
     */
    data: EvaluationParameterCreateManyInput | EvaluationParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvaluationParameter update
   */
  export type EvaluationParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameter
     */
    select?: EvaluationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationParameter
     */
    omit?: EvaluationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationParameterInclude<ExtArgs> | null
    /**
     * The data needed to update a EvaluationParameter.
     */
    data: XOR<EvaluationParameterUpdateInput, EvaluationParameterUncheckedUpdateInput>
    /**
     * Choose, which EvaluationParameter to update.
     */
    where: EvaluationParameterWhereUniqueInput
  }

  /**
   * EvaluationParameter updateMany
   */
  export type EvaluationParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaluationParameters.
     */
    data: XOR<EvaluationParameterUpdateManyMutationInput, EvaluationParameterUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationParameters to update
     */
    where?: EvaluationParameterWhereInput
    /**
     * Limit how many EvaluationParameters to update.
     */
    limit?: number
  }

  /**
   * EvaluationParameter updateManyAndReturn
   */
  export type EvaluationParameterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameter
     */
    select?: EvaluationParameterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationParameter
     */
    omit?: EvaluationParameterOmit<ExtArgs> | null
    /**
     * The data used to update EvaluationParameters.
     */
    data: XOR<EvaluationParameterUpdateManyMutationInput, EvaluationParameterUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationParameters to update
     */
    where?: EvaluationParameterWhereInput
    /**
     * Limit how many EvaluationParameters to update.
     */
    limit?: number
  }

  /**
   * EvaluationParameter upsert
   */
  export type EvaluationParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameter
     */
    select?: EvaluationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationParameter
     */
    omit?: EvaluationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationParameterInclude<ExtArgs> | null
    /**
     * The filter to search for the EvaluationParameter to update in case it exists.
     */
    where: EvaluationParameterWhereUniqueInput
    /**
     * In case the EvaluationParameter found by the `where` argument doesn't exist, create a new EvaluationParameter with this data.
     */
    create: XOR<EvaluationParameterCreateInput, EvaluationParameterUncheckedCreateInput>
    /**
     * In case the EvaluationParameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationParameterUpdateInput, EvaluationParameterUncheckedUpdateInput>
  }

  /**
   * EvaluationParameter delete
   */
  export type EvaluationParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameter
     */
    select?: EvaluationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationParameter
     */
    omit?: EvaluationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationParameterInclude<ExtArgs> | null
    /**
     * Filter which EvaluationParameter to delete.
     */
    where: EvaluationParameterWhereUniqueInput
  }

  /**
   * EvaluationParameter deleteMany
   */
  export type EvaluationParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationParameters to delete
     */
    where?: EvaluationParameterWhereInput
    /**
     * Limit how many EvaluationParameters to delete.
     */
    limit?: number
  }

  /**
   * EvaluationParameter.evaluationScores
   */
  export type EvaluationParameter$evaluationScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreInclude<ExtArgs> | null
    where?: EvaluationScoreWhereInput
    orderBy?: EvaluationScoreOrderByWithRelationInput | EvaluationScoreOrderByWithRelationInput[]
    cursor?: EvaluationScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScoreScalarFieldEnum | EvaluationScoreScalarFieldEnum[]
  }

  /**
   * EvaluationParameter without action
   */
  export type EvaluationParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationParameter
     */
    select?: EvaluationParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationParameter
     */
    omit?: EvaluationParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationParameterInclude<ExtArgs> | null
  }


  /**
   * Model Evaluation
   */

  export type AggregateEvaluation = {
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  export type EvaluationAvgAggregateOutputType = {
    ranking: number | null
  }

  export type EvaluationSumAggregateOutputType = {
    ranking: number | null
  }

  export type EvaluationMinAggregateOutputType = {
    id: string | null
    evaluatorId: string | null
    periodId: string | null
    targetUserId: string | null
    ranking: number | null
    status: $Enums.EvaluationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationMaxAggregateOutputType = {
    id: string | null
    evaluatorId: string | null
    periodId: string | null
    targetUserId: string | null
    ranking: number | null
    status: $Enums.EvaluationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationCountAggregateOutputType = {
    id: number
    evaluatorId: number
    periodId: number
    targetUserId: number
    ranking: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvaluationAvgAggregateInputType = {
    ranking?: true
  }

  export type EvaluationSumAggregateInputType = {
    ranking?: true
  }

  export type EvaluationMinAggregateInputType = {
    id?: true
    evaluatorId?: true
    periodId?: true
    targetUserId?: true
    ranking?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationMaxAggregateInputType = {
    id?: true
    evaluatorId?: true
    periodId?: true
    targetUserId?: true
    ranking?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationCountAggregateInputType = {
    id?: true
    evaluatorId?: true
    periodId?: true
    targetUserId?: true
    ranking?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluation to aggregate.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evaluations
    **/
    _count?: true | EvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationMaxAggregateInputType
  }

  export type GetEvaluationAggregateType<T extends EvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluation[P]>
      : GetScalarType<T[P], AggregateEvaluation[P]>
  }




  export type EvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithAggregationInput | EvaluationOrderByWithAggregationInput[]
    by: EvaluationScalarFieldEnum[] | EvaluationScalarFieldEnum
    having?: EvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationCountAggregateInputType | true
    _avg?: EvaluationAvgAggregateInputType
    _sum?: EvaluationSumAggregateInputType
    _min?: EvaluationMinAggregateInputType
    _max?: EvaluationMaxAggregateInputType
  }

  export type EvaluationGroupByOutputType = {
    id: string
    evaluatorId: string
    periodId: string
    targetUserId: string
    ranking: number
    status: $Enums.EvaluationStatus
    createdAt: Date
    updatedAt: Date
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  type GetEvaluationGroupByPayload<T extends EvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluatorId?: boolean
    periodId?: boolean
    targetUserId?: boolean
    ranking?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
    scores?: boolean | Evaluation$scoresArgs<ExtArgs>
    _count?: boolean | EvaluationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluatorId?: boolean
    periodId?: boolean
    targetUserId?: boolean
    ranking?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluatorId?: boolean
    periodId?: boolean
    targetUserId?: boolean
    ranking?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectScalar = {
    id?: boolean
    evaluatorId?: boolean
    periodId?: boolean
    targetUserId?: boolean
    ranking?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EvaluationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "evaluatorId" | "periodId" | "targetUserId" | "ranking" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["evaluation"]>
  export type EvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
    scores?: boolean | Evaluation$scoresArgs<ExtArgs>
    _count?: boolean | EvaluationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EvaluationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }
  export type EvaluationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
    target?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }

  export type $EvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evaluation"
    objects: {
      evaluator: Prisma.$UserPayload<ExtArgs>
      target: Prisma.$UserPayload<ExtArgs>
      period: Prisma.$PeriodPayload<ExtArgs>
      scores: Prisma.$EvaluationScorePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      evaluatorId: string
      periodId: string
      targetUserId: string
      ranking: number
      status: $Enums.EvaluationStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evaluation"]>
    composites: {}
  }

  type EvaluationGetPayload<S extends boolean | null | undefined | EvaluationDefaultArgs> = $Result.GetResult<Prisma.$EvaluationPayload, S>

  type EvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvaluationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvaluationCountAggregateInputType | true
    }

  export interface EvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evaluation'], meta: { name: 'Evaluation' } }
    /**
     * Find zero or one Evaluation that matches the filter.
     * @param {EvaluationFindUniqueArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationFindUniqueArgs>(args: SelectSubset<T, EvaluationFindUniqueArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evaluation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvaluationFindUniqueOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationFindFirstArgs>(args?: SelectSubset<T, EvaluationFindFirstArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Evaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluations
     * const evaluations = await prisma.evaluation.findMany()
     * 
     * // Get first 10 Evaluations
     * const evaluations = await prisma.evaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationFindManyArgs>(args?: SelectSubset<T, EvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evaluation.
     * @param {EvaluationCreateArgs} args - Arguments to create a Evaluation.
     * @example
     * // Create one Evaluation
     * const Evaluation = await prisma.evaluation.create({
     *   data: {
     *     // ... data to create a Evaluation
     *   }
     * })
     * 
     */
    create<T extends EvaluationCreateArgs>(args: SelectSubset<T, EvaluationCreateArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Evaluations.
     * @param {EvaluationCreateManyArgs} args - Arguments to create many Evaluations.
     * @example
     * // Create many Evaluations
     * const evaluation = await prisma.evaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationCreateManyArgs>(args?: SelectSubset<T, EvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evaluations and returns the data saved in the database.
     * @param {EvaluationCreateManyAndReturnArgs} args - Arguments to create many Evaluations.
     * @example
     * // Create many Evaluations
     * const evaluation = await prisma.evaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evaluations and only return the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluationCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Evaluation.
     * @param {EvaluationDeleteArgs} args - Arguments to delete one Evaluation.
     * @example
     * // Delete one Evaluation
     * const Evaluation = await prisma.evaluation.delete({
     *   where: {
     *     // ... filter to delete one Evaluation
     *   }
     * })
     * 
     */
    delete<T extends EvaluationDeleteArgs>(args: SelectSubset<T, EvaluationDeleteArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evaluation.
     * @param {EvaluationUpdateArgs} args - Arguments to update one Evaluation.
     * @example
     * // Update one Evaluation
     * const evaluation = await prisma.evaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationUpdateArgs>(args: SelectSubset<T, EvaluationUpdateArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Evaluations.
     * @param {EvaluationDeleteManyArgs} args - Arguments to filter Evaluations to delete.
     * @example
     * // Delete a few Evaluations
     * const { count } = await prisma.evaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationDeleteManyArgs>(args?: SelectSubset<T, EvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluations
     * const evaluation = await prisma.evaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationUpdateManyArgs>(args: SelectSubset<T, EvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluations and returns the data updated in the database.
     * @param {EvaluationUpdateManyAndReturnArgs} args - Arguments to update many Evaluations.
     * @example
     * // Update many Evaluations
     * const evaluation = await prisma.evaluation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Evaluations and only return the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvaluationUpdateManyAndReturnArgs>(args: SelectSubset<T, EvaluationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Evaluation.
     * @param {EvaluationUpsertArgs} args - Arguments to update or create a Evaluation.
     * @example
     * // Update or create a Evaluation
     * const evaluation = await prisma.evaluation.upsert({
     *   create: {
     *     // ... data to create a Evaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluation we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationUpsertArgs>(args: SelectSubset<T, EvaluationUpsertArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationCountArgs} args - Arguments to filter Evaluations to count.
     * @example
     * // Count the number of Evaluations
     * const count = await prisma.evaluation.count({
     *   where: {
     *     // ... the filter for the Evaluations we want to count
     *   }
     * })
    **/
    count<T extends EvaluationCountArgs>(
      args?: Subset<T, EvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationAggregateArgs>(args: Subset<T, EvaluationAggregateArgs>): Prisma.PrismaPromise<GetEvaluationAggregateType<T>>

    /**
     * Group by Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evaluation model
   */
  readonly fields: EvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    target<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    period<T extends PeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PeriodDefaultArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scores<T extends Evaluation$scoresArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$scoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evaluation model
   */
  interface EvaluationFieldRefs {
    readonly id: FieldRef<"Evaluation", 'String'>
    readonly evaluatorId: FieldRef<"Evaluation", 'String'>
    readonly periodId: FieldRef<"Evaluation", 'String'>
    readonly targetUserId: FieldRef<"Evaluation", 'String'>
    readonly ranking: FieldRef<"Evaluation", 'Int'>
    readonly status: FieldRef<"Evaluation", 'EvaluationStatus'>
    readonly createdAt: FieldRef<"Evaluation", 'DateTime'>
    readonly updatedAt: FieldRef<"Evaluation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evaluation findUnique
   */
  export type EvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findUniqueOrThrow
   */
  export type EvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findFirst
   */
  export type EvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation findFirstOrThrow
   */
  export type EvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation findMany
   */
  export type EvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluations to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }

  /**
   * Evaluation create
   */
  export type EvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a Evaluation.
     */
    data: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
  }

  /**
   * Evaluation createMany
   */
  export type EvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evaluation createManyAndReturn
   */
  export type EvaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evaluation update
   */
  export type EvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a Evaluation.
     */
    data: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
    /**
     * Choose, which Evaluation to update.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation updateMany
   */
  export type EvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evaluations.
     */
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyInput>
    /**
     * Filter which Evaluations to update
     */
    where?: EvaluationWhereInput
    /**
     * Limit how many Evaluations to update.
     */
    limit?: number
  }

  /**
   * Evaluation updateManyAndReturn
   */
  export type EvaluationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * The data used to update Evaluations.
     */
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyInput>
    /**
     * Filter which Evaluations to update
     */
    where?: EvaluationWhereInput
    /**
     * Limit how many Evaluations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evaluation upsert
   */
  export type EvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the Evaluation to update in case it exists.
     */
    where: EvaluationWhereUniqueInput
    /**
     * In case the Evaluation found by the `where` argument doesn't exist, create a new Evaluation with this data.
     */
    create: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
    /**
     * In case the Evaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
  }

  /**
   * Evaluation delete
   */
  export type EvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter which Evaluation to delete.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation deleteMany
   */
  export type EvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluations to delete
     */
    where?: EvaluationWhereInput
    /**
     * Limit how many Evaluations to delete.
     */
    limit?: number
  }

  /**
   * Evaluation.scores
   */
  export type Evaluation$scoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreInclude<ExtArgs> | null
    where?: EvaluationScoreWhereInput
    orderBy?: EvaluationScoreOrderByWithRelationInput | EvaluationScoreOrderByWithRelationInput[]
    cursor?: EvaluationScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScoreScalarFieldEnum | EvaluationScoreScalarFieldEnum[]
  }

  /**
   * Evaluation without action
   */
  export type EvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluation
     */
    omit?: EvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationInclude<ExtArgs> | null
  }


  /**
   * Model EvaluationScore
   */

  export type AggregateEvaluationScore = {
    _count: EvaluationScoreCountAggregateOutputType | null
    _avg: EvaluationScoreAvgAggregateOutputType | null
    _sum: EvaluationScoreSumAggregateOutputType | null
    _min: EvaluationScoreMinAggregateOutputType | null
    _max: EvaluationScoreMaxAggregateOutputType | null
  }

  export type EvaluationScoreAvgAggregateOutputType = {
    score: number | null
  }

  export type EvaluationScoreSumAggregateOutputType = {
    score: number | null
  }

  export type EvaluationScoreMinAggregateOutputType = {
    id: string | null
    evaluationId: string | null
    parameterId: string | null
    score: number | null
    createdAt: Date | null
  }

  export type EvaluationScoreMaxAggregateOutputType = {
    id: string | null
    evaluationId: string | null
    parameterId: string | null
    score: number | null
    createdAt: Date | null
  }

  export type EvaluationScoreCountAggregateOutputType = {
    id: number
    evaluationId: number
    parameterId: number
    score: number
    createdAt: number
    _all: number
  }


  export type EvaluationScoreAvgAggregateInputType = {
    score?: true
  }

  export type EvaluationScoreSumAggregateInputType = {
    score?: true
  }

  export type EvaluationScoreMinAggregateInputType = {
    id?: true
    evaluationId?: true
    parameterId?: true
    score?: true
    createdAt?: true
  }

  export type EvaluationScoreMaxAggregateInputType = {
    id?: true
    evaluationId?: true
    parameterId?: true
    score?: true
    createdAt?: true
  }

  export type EvaluationScoreCountAggregateInputType = {
    id?: true
    evaluationId?: true
    parameterId?: true
    score?: true
    createdAt?: true
    _all?: true
  }

  export type EvaluationScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationScore to aggregate.
     */
    where?: EvaluationScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationScores to fetch.
     */
    orderBy?: EvaluationScoreOrderByWithRelationInput | EvaluationScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaluationScores
    **/
    _count?: true | EvaluationScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationScoreMaxAggregateInputType
  }

  export type GetEvaluationScoreAggregateType<T extends EvaluationScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluationScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluationScore[P]>
      : GetScalarType<T[P], AggregateEvaluationScore[P]>
  }




  export type EvaluationScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationScoreWhereInput
    orderBy?: EvaluationScoreOrderByWithAggregationInput | EvaluationScoreOrderByWithAggregationInput[]
    by: EvaluationScoreScalarFieldEnum[] | EvaluationScoreScalarFieldEnum
    having?: EvaluationScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationScoreCountAggregateInputType | true
    _avg?: EvaluationScoreAvgAggregateInputType
    _sum?: EvaluationScoreSumAggregateInputType
    _min?: EvaluationScoreMinAggregateInputType
    _max?: EvaluationScoreMaxAggregateInputType
  }

  export type EvaluationScoreGroupByOutputType = {
    id: string
    evaluationId: string
    parameterId: string
    score: number
    createdAt: Date
    _count: EvaluationScoreCountAggregateOutputType | null
    _avg: EvaluationScoreAvgAggregateOutputType | null
    _sum: EvaluationScoreSumAggregateOutputType | null
    _min: EvaluationScoreMinAggregateOutputType | null
    _max: EvaluationScoreMaxAggregateOutputType | null
  }

  type GetEvaluationScoreGroupByPayload<T extends EvaluationScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationScoreGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationScoreGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluationId?: boolean
    parameterId?: boolean
    score?: boolean
    createdAt?: boolean
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
    parameter?: boolean | EvaluationParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationScore"]>

  export type EvaluationScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluationId?: boolean
    parameterId?: boolean
    score?: boolean
    createdAt?: boolean
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
    parameter?: boolean | EvaluationParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationScore"]>

  export type EvaluationScoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evaluationId?: boolean
    parameterId?: boolean
    score?: boolean
    createdAt?: boolean
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
    parameter?: boolean | EvaluationParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationScore"]>

  export type EvaluationScoreSelectScalar = {
    id?: boolean
    evaluationId?: boolean
    parameterId?: boolean
    score?: boolean
    createdAt?: boolean
  }

  export type EvaluationScoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "evaluationId" | "parameterId" | "score" | "createdAt", ExtArgs["result"]["evaluationScore"]>
  export type EvaluationScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
    parameter?: boolean | EvaluationParameterDefaultArgs<ExtArgs>
  }
  export type EvaluationScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
    parameter?: boolean | EvaluationParameterDefaultArgs<ExtArgs>
  }
  export type EvaluationScoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluation?: boolean | EvaluationDefaultArgs<ExtArgs>
    parameter?: boolean | EvaluationParameterDefaultArgs<ExtArgs>
  }

  export type $EvaluationScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaluationScore"
    objects: {
      evaluation: Prisma.$EvaluationPayload<ExtArgs>
      parameter: Prisma.$EvaluationParameterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      evaluationId: string
      parameterId: string
      score: number
      createdAt: Date
    }, ExtArgs["result"]["evaluationScore"]>
    composites: {}
  }

  type EvaluationScoreGetPayload<S extends boolean | null | undefined | EvaluationScoreDefaultArgs> = $Result.GetResult<Prisma.$EvaluationScorePayload, S>

  type EvaluationScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvaluationScoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvaluationScoreCountAggregateInputType | true
    }

  export interface EvaluationScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaluationScore'], meta: { name: 'EvaluationScore' } }
    /**
     * Find zero or one EvaluationScore that matches the filter.
     * @param {EvaluationScoreFindUniqueArgs} args - Arguments to find a EvaluationScore
     * @example
     * // Get one EvaluationScore
     * const evaluationScore = await prisma.evaluationScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationScoreFindUniqueArgs>(args: SelectSubset<T, EvaluationScoreFindUniqueArgs<ExtArgs>>): Prisma__EvaluationScoreClient<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EvaluationScore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvaluationScoreFindUniqueOrThrowArgs} args - Arguments to find a EvaluationScore
     * @example
     * // Get one EvaluationScore
     * const evaluationScore = await prisma.evaluationScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationScoreClient<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvaluationScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationScoreFindFirstArgs} args - Arguments to find a EvaluationScore
     * @example
     * // Get one EvaluationScore
     * const evaluationScore = await prisma.evaluationScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationScoreFindFirstArgs>(args?: SelectSubset<T, EvaluationScoreFindFirstArgs<ExtArgs>>): Prisma__EvaluationScoreClient<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvaluationScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationScoreFindFirstOrThrowArgs} args - Arguments to find a EvaluationScore
     * @example
     * // Get one EvaluationScore
     * const evaluationScore = await prisma.evaluationScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationScoreClient<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EvaluationScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaluationScores
     * const evaluationScores = await prisma.evaluationScore.findMany()
     * 
     * // Get first 10 EvaluationScores
     * const evaluationScores = await prisma.evaluationScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationScoreWithIdOnly = await prisma.evaluationScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationScoreFindManyArgs>(args?: SelectSubset<T, EvaluationScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EvaluationScore.
     * @param {EvaluationScoreCreateArgs} args - Arguments to create a EvaluationScore.
     * @example
     * // Create one EvaluationScore
     * const EvaluationScore = await prisma.evaluationScore.create({
     *   data: {
     *     // ... data to create a EvaluationScore
     *   }
     * })
     * 
     */
    create<T extends EvaluationScoreCreateArgs>(args: SelectSubset<T, EvaluationScoreCreateArgs<ExtArgs>>): Prisma__EvaluationScoreClient<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EvaluationScores.
     * @param {EvaluationScoreCreateManyArgs} args - Arguments to create many EvaluationScores.
     * @example
     * // Create many EvaluationScores
     * const evaluationScore = await prisma.evaluationScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationScoreCreateManyArgs>(args?: SelectSubset<T, EvaluationScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvaluationScores and returns the data saved in the database.
     * @param {EvaluationScoreCreateManyAndReturnArgs} args - Arguments to create many EvaluationScores.
     * @example
     * // Create many EvaluationScores
     * const evaluationScore = await prisma.evaluationScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvaluationScores and only return the `id`
     * const evaluationScoreWithIdOnly = await prisma.evaluationScore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluationScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluationScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EvaluationScore.
     * @param {EvaluationScoreDeleteArgs} args - Arguments to delete one EvaluationScore.
     * @example
     * // Delete one EvaluationScore
     * const EvaluationScore = await prisma.evaluationScore.delete({
     *   where: {
     *     // ... filter to delete one EvaluationScore
     *   }
     * })
     * 
     */
    delete<T extends EvaluationScoreDeleteArgs>(args: SelectSubset<T, EvaluationScoreDeleteArgs<ExtArgs>>): Prisma__EvaluationScoreClient<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EvaluationScore.
     * @param {EvaluationScoreUpdateArgs} args - Arguments to update one EvaluationScore.
     * @example
     * // Update one EvaluationScore
     * const evaluationScore = await prisma.evaluationScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationScoreUpdateArgs>(args: SelectSubset<T, EvaluationScoreUpdateArgs<ExtArgs>>): Prisma__EvaluationScoreClient<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EvaluationScores.
     * @param {EvaluationScoreDeleteManyArgs} args - Arguments to filter EvaluationScores to delete.
     * @example
     * // Delete a few EvaluationScores
     * const { count } = await prisma.evaluationScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationScoreDeleteManyArgs>(args?: SelectSubset<T, EvaluationScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaluationScores
     * const evaluationScore = await prisma.evaluationScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationScoreUpdateManyArgs>(args: SelectSubset<T, EvaluationScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationScores and returns the data updated in the database.
     * @param {EvaluationScoreUpdateManyAndReturnArgs} args - Arguments to update many EvaluationScores.
     * @example
     * // Update many EvaluationScores
     * const evaluationScore = await prisma.evaluationScore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EvaluationScores and only return the `id`
     * const evaluationScoreWithIdOnly = await prisma.evaluationScore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvaluationScoreUpdateManyAndReturnArgs>(args: SelectSubset<T, EvaluationScoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EvaluationScore.
     * @param {EvaluationScoreUpsertArgs} args - Arguments to update or create a EvaluationScore.
     * @example
     * // Update or create a EvaluationScore
     * const evaluationScore = await prisma.evaluationScore.upsert({
     *   create: {
     *     // ... data to create a EvaluationScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaluationScore we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationScoreUpsertArgs>(args: SelectSubset<T, EvaluationScoreUpsertArgs<ExtArgs>>): Prisma__EvaluationScoreClient<$Result.GetResult<Prisma.$EvaluationScorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EvaluationScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationScoreCountArgs} args - Arguments to filter EvaluationScores to count.
     * @example
     * // Count the number of EvaluationScores
     * const count = await prisma.evaluationScore.count({
     *   where: {
     *     // ... the filter for the EvaluationScores we want to count
     *   }
     * })
    **/
    count<T extends EvaluationScoreCountArgs>(
      args?: Subset<T, EvaluationScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaluationScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationScoreAggregateArgs>(args: Subset<T, EvaluationScoreAggregateArgs>): Prisma.PrismaPromise<GetEvaluationScoreAggregateType<T>>

    /**
     * Group by EvaluationScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationScoreGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaluationScore model
   */
  readonly fields: EvaluationScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaluationScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluation<T extends EvaluationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationDefaultArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parameter<T extends EvaluationParameterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EvaluationParameterDefaultArgs<ExtArgs>>): Prisma__EvaluationParameterClient<$Result.GetResult<Prisma.$EvaluationParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvaluationScore model
   */
  interface EvaluationScoreFieldRefs {
    readonly id: FieldRef<"EvaluationScore", 'String'>
    readonly evaluationId: FieldRef<"EvaluationScore", 'String'>
    readonly parameterId: FieldRef<"EvaluationScore", 'String'>
    readonly score: FieldRef<"EvaluationScore", 'Int'>
    readonly createdAt: FieldRef<"EvaluationScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvaluationScore findUnique
   */
  export type EvaluationScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationScore to fetch.
     */
    where: EvaluationScoreWhereUniqueInput
  }

  /**
   * EvaluationScore findUniqueOrThrow
   */
  export type EvaluationScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationScore to fetch.
     */
    where: EvaluationScoreWhereUniqueInput
  }

  /**
   * EvaluationScore findFirst
   */
  export type EvaluationScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationScore to fetch.
     */
    where?: EvaluationScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationScores to fetch.
     */
    orderBy?: EvaluationScoreOrderByWithRelationInput | EvaluationScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationScores.
     */
    cursor?: EvaluationScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationScores.
     */
    distinct?: EvaluationScoreScalarFieldEnum | EvaluationScoreScalarFieldEnum[]
  }

  /**
   * EvaluationScore findFirstOrThrow
   */
  export type EvaluationScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationScore to fetch.
     */
    where?: EvaluationScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationScores to fetch.
     */
    orderBy?: EvaluationScoreOrderByWithRelationInput | EvaluationScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationScores.
     */
    cursor?: EvaluationScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationScores.
     */
    distinct?: EvaluationScoreScalarFieldEnum | EvaluationScoreScalarFieldEnum[]
  }

  /**
   * EvaluationScore findMany
   */
  export type EvaluationScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationScores to fetch.
     */
    where?: EvaluationScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationScores to fetch.
     */
    orderBy?: EvaluationScoreOrderByWithRelationInput | EvaluationScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaluationScores.
     */
    cursor?: EvaluationScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationScores.
     */
    skip?: number
    distinct?: EvaluationScoreScalarFieldEnum | EvaluationScoreScalarFieldEnum[]
  }

  /**
   * EvaluationScore create
   */
  export type EvaluationScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a EvaluationScore.
     */
    data: XOR<EvaluationScoreCreateInput, EvaluationScoreUncheckedCreateInput>
  }

  /**
   * EvaluationScore createMany
   */
  export type EvaluationScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaluationScores.
     */
    data: EvaluationScoreCreateManyInput | EvaluationScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvaluationScore createManyAndReturn
   */
  export type EvaluationScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * The data used to create many EvaluationScores.
     */
    data: EvaluationScoreCreateManyInput | EvaluationScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvaluationScore update
   */
  export type EvaluationScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a EvaluationScore.
     */
    data: XOR<EvaluationScoreUpdateInput, EvaluationScoreUncheckedUpdateInput>
    /**
     * Choose, which EvaluationScore to update.
     */
    where: EvaluationScoreWhereUniqueInput
  }

  /**
   * EvaluationScore updateMany
   */
  export type EvaluationScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaluationScores.
     */
    data: XOR<EvaluationScoreUpdateManyMutationInput, EvaluationScoreUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationScores to update
     */
    where?: EvaluationScoreWhereInput
    /**
     * Limit how many EvaluationScores to update.
     */
    limit?: number
  }

  /**
   * EvaluationScore updateManyAndReturn
   */
  export type EvaluationScoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * The data used to update EvaluationScores.
     */
    data: XOR<EvaluationScoreUpdateManyMutationInput, EvaluationScoreUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationScores to update
     */
    where?: EvaluationScoreWhereInput
    /**
     * Limit how many EvaluationScores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvaluationScore upsert
   */
  export type EvaluationScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the EvaluationScore to update in case it exists.
     */
    where: EvaluationScoreWhereUniqueInput
    /**
     * In case the EvaluationScore found by the `where` argument doesn't exist, create a new EvaluationScore with this data.
     */
    create: XOR<EvaluationScoreCreateInput, EvaluationScoreUncheckedCreateInput>
    /**
     * In case the EvaluationScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationScoreUpdateInput, EvaluationScoreUncheckedUpdateInput>
  }

  /**
   * EvaluationScore delete
   */
  export type EvaluationScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreInclude<ExtArgs> | null
    /**
     * Filter which EvaluationScore to delete.
     */
    where: EvaluationScoreWhereUniqueInput
  }

  /**
   * EvaluationScore deleteMany
   */
  export type EvaluationScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationScores to delete
     */
    where?: EvaluationScoreWhereInput
    /**
     * Limit how many EvaluationScores to delete.
     */
    limit?: number
  }

  /**
   * EvaluationScore without action
   */
  export type EvaluationScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationScore
     */
    select?: EvaluationScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvaluationScore
     */
    omit?: EvaluationScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationScoreInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    persentaseTotal: number | null
    tidakKerja: number | null
    pulangAwal: number | null
    telat: number | null
    absenApel: number | null
    cuti: number | null
    totalMinus: number | null
    nilaiPresensi: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    persentaseTotal: number | null
    tidakKerja: number | null
    pulangAwal: number | null
    telat: number | null
    absenApel: number | null
    cuti: number | null
    totalMinus: number | null
    nilaiPresensi: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    periodId: string | null
    persentaseTotal: number | null
    tidakKerja: number | null
    pulangAwal: number | null
    telat: number | null
    absenApel: number | null
    cuti: number | null
    totalMinus: number | null
    nilaiPresensi: number | null
    keterangan: string | null
    inputBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    periodId: string | null
    persentaseTotal: number | null
    tidakKerja: number | null
    pulangAwal: number | null
    telat: number | null
    absenApel: number | null
    cuti: number | null
    totalMinus: number | null
    nilaiPresensi: number | null
    keterangan: string | null
    inputBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    userId: number
    periodId: number
    persentaseTotal: number
    tidakKerja: number
    pulangAwal: number
    telat: number
    absenApel: number
    cuti: number
    totalMinus: number
    nilaiPresensi: number
    keterangan: number
    inputBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    persentaseTotal?: true
    tidakKerja?: true
    pulangAwal?: true
    telat?: true
    absenApel?: true
    cuti?: true
    totalMinus?: true
    nilaiPresensi?: true
  }

  export type AttendanceSumAggregateInputType = {
    persentaseTotal?: true
    tidakKerja?: true
    pulangAwal?: true
    telat?: true
    absenApel?: true
    cuti?: true
    totalMinus?: true
    nilaiPresensi?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    userId?: true
    periodId?: true
    persentaseTotal?: true
    tidakKerja?: true
    pulangAwal?: true
    telat?: true
    absenApel?: true
    cuti?: true
    totalMinus?: true
    nilaiPresensi?: true
    keterangan?: true
    inputBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    userId?: true
    periodId?: true
    persentaseTotal?: true
    tidakKerja?: true
    pulangAwal?: true
    telat?: true
    absenApel?: true
    cuti?: true
    totalMinus?: true
    nilaiPresensi?: true
    keterangan?: true
    inputBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    userId?: true
    periodId?: true
    persentaseTotal?: true
    tidakKerja?: true
    pulangAwal?: true
    telat?: true
    absenApel?: true
    cuti?: true
    totalMinus?: true
    nilaiPresensi?: true
    keterangan?: true
    inputBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    userId: string
    periodId: string
    persentaseTotal: number
    tidakKerja: number
    pulangAwal: number
    telat: number
    absenApel: number
    cuti: number
    totalMinus: number
    nilaiPresensi: number
    keterangan: string | null
    inputBy: string
    createdAt: Date
    updatedAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    periodId?: boolean
    persentaseTotal?: boolean
    tidakKerja?: boolean
    pulangAwal?: boolean
    telat?: boolean
    absenApel?: boolean
    cuti?: boolean
    totalMinus?: boolean
    nilaiPresensi?: boolean
    keterangan?: boolean
    inputBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    periodId?: boolean
    persentaseTotal?: boolean
    tidakKerja?: boolean
    pulangAwal?: boolean
    telat?: boolean
    absenApel?: boolean
    cuti?: boolean
    totalMinus?: boolean
    nilaiPresensi?: boolean
    keterangan?: boolean
    inputBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    periodId?: boolean
    persentaseTotal?: boolean
    tidakKerja?: boolean
    pulangAwal?: boolean
    telat?: boolean
    absenApel?: boolean
    cuti?: boolean
    totalMinus?: boolean
    nilaiPresensi?: boolean
    keterangan?: boolean
    inputBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    userId?: boolean
    periodId?: boolean
    persentaseTotal?: boolean
    tidakKerja?: boolean
    pulangAwal?: boolean
    telat?: boolean
    absenApel?: boolean
    cuti?: boolean
    totalMinus?: boolean
    nilaiPresensi?: boolean
    keterangan?: boolean
    inputBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "periodId" | "persentaseTotal" | "tidakKerja" | "pulangAwal" | "telat" | "absenApel" | "cuti" | "totalMinus" | "nilaiPresensi" | "keterangan" | "inputBy" | "createdAt" | "updatedAt", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      period: Prisma.$PeriodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      periodId: string
      persentaseTotal: number
      tidakKerja: number
      pulangAwal: number
      telat: number
      absenApel: number
      cuti: number
      totalMinus: number
      nilaiPresensi: number
      keterangan: string | null
      inputBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    period<T extends PeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PeriodDefaultArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly userId: FieldRef<"Attendance", 'String'>
    readonly periodId: FieldRef<"Attendance", 'String'>
    readonly persentaseTotal: FieldRef<"Attendance", 'Float'>
    readonly tidakKerja: FieldRef<"Attendance", 'Float'>
    readonly pulangAwal: FieldRef<"Attendance", 'Float'>
    readonly telat: FieldRef<"Attendance", 'Float'>
    readonly absenApel: FieldRef<"Attendance", 'Float'>
    readonly cuti: FieldRef<"Attendance", 'Float'>
    readonly totalMinus: FieldRef<"Attendance", 'Float'>
    readonly nilaiPresensi: FieldRef<"Attendance", 'Float'>
    readonly keterangan: FieldRef<"Attendance", 'String'>
    readonly inputBy: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
    readonly updatedAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model CkpScore
   */

  export type AggregateCkpScore = {
    _count: CkpScoreCountAggregateOutputType | null
    _avg: CkpScoreAvgAggregateOutputType | null
    _sum: CkpScoreSumAggregateOutputType | null
    _min: CkpScoreMinAggregateOutputType | null
    _max: CkpScoreMaxAggregateOutputType | null
  }

  export type CkpScoreAvgAggregateOutputType = {
    score: number | null
  }

  export type CkpScoreSumAggregateOutputType = {
    score: number | null
  }

  export type CkpScoreMinAggregateOutputType = {
    id: string | null
    userId: string | null
    periodId: string | null
    score: number | null
    keterangan: string | null
    inputBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CkpScoreMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    periodId: string | null
    score: number | null
    keterangan: string | null
    inputBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CkpScoreCountAggregateOutputType = {
    id: number
    userId: number
    periodId: number
    score: number
    keterangan: number
    inputBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CkpScoreAvgAggregateInputType = {
    score?: true
  }

  export type CkpScoreSumAggregateInputType = {
    score?: true
  }

  export type CkpScoreMinAggregateInputType = {
    id?: true
    userId?: true
    periodId?: true
    score?: true
    keterangan?: true
    inputBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CkpScoreMaxAggregateInputType = {
    id?: true
    userId?: true
    periodId?: true
    score?: true
    keterangan?: true
    inputBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CkpScoreCountAggregateInputType = {
    id?: true
    userId?: true
    periodId?: true
    score?: true
    keterangan?: true
    inputBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CkpScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CkpScore to aggregate.
     */
    where?: CkpScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CkpScores to fetch.
     */
    orderBy?: CkpScoreOrderByWithRelationInput | CkpScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CkpScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CkpScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CkpScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CkpScores
    **/
    _count?: true | CkpScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CkpScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CkpScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CkpScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CkpScoreMaxAggregateInputType
  }

  export type GetCkpScoreAggregateType<T extends CkpScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateCkpScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCkpScore[P]>
      : GetScalarType<T[P], AggregateCkpScore[P]>
  }




  export type CkpScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CkpScoreWhereInput
    orderBy?: CkpScoreOrderByWithAggregationInput | CkpScoreOrderByWithAggregationInput[]
    by: CkpScoreScalarFieldEnum[] | CkpScoreScalarFieldEnum
    having?: CkpScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CkpScoreCountAggregateInputType | true
    _avg?: CkpScoreAvgAggregateInputType
    _sum?: CkpScoreSumAggregateInputType
    _min?: CkpScoreMinAggregateInputType
    _max?: CkpScoreMaxAggregateInputType
  }

  export type CkpScoreGroupByOutputType = {
    id: string
    userId: string
    periodId: string
    score: number
    keterangan: string | null
    inputBy: string
    createdAt: Date
    updatedAt: Date
    _count: CkpScoreCountAggregateOutputType | null
    _avg: CkpScoreAvgAggregateOutputType | null
    _sum: CkpScoreSumAggregateOutputType | null
    _min: CkpScoreMinAggregateOutputType | null
    _max: CkpScoreMaxAggregateOutputType | null
  }

  type GetCkpScoreGroupByPayload<T extends CkpScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CkpScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CkpScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CkpScoreGroupByOutputType[P]>
            : GetScalarType<T[P], CkpScoreGroupByOutputType[P]>
        }
      >
    >


  export type CkpScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    periodId?: boolean
    score?: boolean
    keterangan?: boolean
    inputBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ckpScore"]>

  export type CkpScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    periodId?: boolean
    score?: boolean
    keterangan?: boolean
    inputBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ckpScore"]>

  export type CkpScoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    periodId?: boolean
    score?: boolean
    keterangan?: boolean
    inputBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ckpScore"]>

  export type CkpScoreSelectScalar = {
    id?: boolean
    userId?: boolean
    periodId?: boolean
    score?: boolean
    keterangan?: boolean
    inputBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CkpScoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "periodId" | "score" | "keterangan" | "inputBy" | "createdAt" | "updatedAt", ExtArgs["result"]["ckpScore"]>
  export type CkpScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }
  export type CkpScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }
  export type CkpScoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }

  export type $CkpScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CkpScore"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      period: Prisma.$PeriodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      periodId: string
      score: number
      keterangan: string | null
      inputBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ckpScore"]>
    composites: {}
  }

  type CkpScoreGetPayload<S extends boolean | null | undefined | CkpScoreDefaultArgs> = $Result.GetResult<Prisma.$CkpScorePayload, S>

  type CkpScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CkpScoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CkpScoreCountAggregateInputType | true
    }

  export interface CkpScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CkpScore'], meta: { name: 'CkpScore' } }
    /**
     * Find zero or one CkpScore that matches the filter.
     * @param {CkpScoreFindUniqueArgs} args - Arguments to find a CkpScore
     * @example
     * // Get one CkpScore
     * const ckpScore = await prisma.ckpScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CkpScoreFindUniqueArgs>(args: SelectSubset<T, CkpScoreFindUniqueArgs<ExtArgs>>): Prisma__CkpScoreClient<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CkpScore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CkpScoreFindUniqueOrThrowArgs} args - Arguments to find a CkpScore
     * @example
     * // Get one CkpScore
     * const ckpScore = await prisma.ckpScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CkpScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, CkpScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CkpScoreClient<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CkpScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CkpScoreFindFirstArgs} args - Arguments to find a CkpScore
     * @example
     * // Get one CkpScore
     * const ckpScore = await prisma.ckpScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CkpScoreFindFirstArgs>(args?: SelectSubset<T, CkpScoreFindFirstArgs<ExtArgs>>): Prisma__CkpScoreClient<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CkpScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CkpScoreFindFirstOrThrowArgs} args - Arguments to find a CkpScore
     * @example
     * // Get one CkpScore
     * const ckpScore = await prisma.ckpScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CkpScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, CkpScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__CkpScoreClient<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CkpScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CkpScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CkpScores
     * const ckpScores = await prisma.ckpScore.findMany()
     * 
     * // Get first 10 CkpScores
     * const ckpScores = await prisma.ckpScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ckpScoreWithIdOnly = await prisma.ckpScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CkpScoreFindManyArgs>(args?: SelectSubset<T, CkpScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CkpScore.
     * @param {CkpScoreCreateArgs} args - Arguments to create a CkpScore.
     * @example
     * // Create one CkpScore
     * const CkpScore = await prisma.ckpScore.create({
     *   data: {
     *     // ... data to create a CkpScore
     *   }
     * })
     * 
     */
    create<T extends CkpScoreCreateArgs>(args: SelectSubset<T, CkpScoreCreateArgs<ExtArgs>>): Prisma__CkpScoreClient<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CkpScores.
     * @param {CkpScoreCreateManyArgs} args - Arguments to create many CkpScores.
     * @example
     * // Create many CkpScores
     * const ckpScore = await prisma.ckpScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CkpScoreCreateManyArgs>(args?: SelectSubset<T, CkpScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CkpScores and returns the data saved in the database.
     * @param {CkpScoreCreateManyAndReturnArgs} args - Arguments to create many CkpScores.
     * @example
     * // Create many CkpScores
     * const ckpScore = await prisma.ckpScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CkpScores and only return the `id`
     * const ckpScoreWithIdOnly = await prisma.ckpScore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CkpScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, CkpScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CkpScore.
     * @param {CkpScoreDeleteArgs} args - Arguments to delete one CkpScore.
     * @example
     * // Delete one CkpScore
     * const CkpScore = await prisma.ckpScore.delete({
     *   where: {
     *     // ... filter to delete one CkpScore
     *   }
     * })
     * 
     */
    delete<T extends CkpScoreDeleteArgs>(args: SelectSubset<T, CkpScoreDeleteArgs<ExtArgs>>): Prisma__CkpScoreClient<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CkpScore.
     * @param {CkpScoreUpdateArgs} args - Arguments to update one CkpScore.
     * @example
     * // Update one CkpScore
     * const ckpScore = await prisma.ckpScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CkpScoreUpdateArgs>(args: SelectSubset<T, CkpScoreUpdateArgs<ExtArgs>>): Prisma__CkpScoreClient<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CkpScores.
     * @param {CkpScoreDeleteManyArgs} args - Arguments to filter CkpScores to delete.
     * @example
     * // Delete a few CkpScores
     * const { count } = await prisma.ckpScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CkpScoreDeleteManyArgs>(args?: SelectSubset<T, CkpScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CkpScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CkpScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CkpScores
     * const ckpScore = await prisma.ckpScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CkpScoreUpdateManyArgs>(args: SelectSubset<T, CkpScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CkpScores and returns the data updated in the database.
     * @param {CkpScoreUpdateManyAndReturnArgs} args - Arguments to update many CkpScores.
     * @example
     * // Update many CkpScores
     * const ckpScore = await prisma.ckpScore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CkpScores and only return the `id`
     * const ckpScoreWithIdOnly = await prisma.ckpScore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CkpScoreUpdateManyAndReturnArgs>(args: SelectSubset<T, CkpScoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CkpScore.
     * @param {CkpScoreUpsertArgs} args - Arguments to update or create a CkpScore.
     * @example
     * // Update or create a CkpScore
     * const ckpScore = await prisma.ckpScore.upsert({
     *   create: {
     *     // ... data to create a CkpScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CkpScore we want to update
     *   }
     * })
     */
    upsert<T extends CkpScoreUpsertArgs>(args: SelectSubset<T, CkpScoreUpsertArgs<ExtArgs>>): Prisma__CkpScoreClient<$Result.GetResult<Prisma.$CkpScorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CkpScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CkpScoreCountArgs} args - Arguments to filter CkpScores to count.
     * @example
     * // Count the number of CkpScores
     * const count = await prisma.ckpScore.count({
     *   where: {
     *     // ... the filter for the CkpScores we want to count
     *   }
     * })
    **/
    count<T extends CkpScoreCountArgs>(
      args?: Subset<T, CkpScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CkpScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CkpScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CkpScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CkpScoreAggregateArgs>(args: Subset<T, CkpScoreAggregateArgs>): Prisma.PrismaPromise<GetCkpScoreAggregateType<T>>

    /**
     * Group by CkpScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CkpScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CkpScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CkpScoreGroupByArgs['orderBy'] }
        : { orderBy?: CkpScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CkpScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCkpScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CkpScore model
   */
  readonly fields: CkpScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CkpScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CkpScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    period<T extends PeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PeriodDefaultArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CkpScore model
   */
  interface CkpScoreFieldRefs {
    readonly id: FieldRef<"CkpScore", 'String'>
    readonly userId: FieldRef<"CkpScore", 'String'>
    readonly periodId: FieldRef<"CkpScore", 'String'>
    readonly score: FieldRef<"CkpScore", 'Float'>
    readonly keterangan: FieldRef<"CkpScore", 'String'>
    readonly inputBy: FieldRef<"CkpScore", 'String'>
    readonly createdAt: FieldRef<"CkpScore", 'DateTime'>
    readonly updatedAt: FieldRef<"CkpScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CkpScore findUnique
   */
  export type CkpScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreInclude<ExtArgs> | null
    /**
     * Filter, which CkpScore to fetch.
     */
    where: CkpScoreWhereUniqueInput
  }

  /**
   * CkpScore findUniqueOrThrow
   */
  export type CkpScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreInclude<ExtArgs> | null
    /**
     * Filter, which CkpScore to fetch.
     */
    where: CkpScoreWhereUniqueInput
  }

  /**
   * CkpScore findFirst
   */
  export type CkpScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreInclude<ExtArgs> | null
    /**
     * Filter, which CkpScore to fetch.
     */
    where?: CkpScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CkpScores to fetch.
     */
    orderBy?: CkpScoreOrderByWithRelationInput | CkpScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CkpScores.
     */
    cursor?: CkpScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CkpScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CkpScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CkpScores.
     */
    distinct?: CkpScoreScalarFieldEnum | CkpScoreScalarFieldEnum[]
  }

  /**
   * CkpScore findFirstOrThrow
   */
  export type CkpScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreInclude<ExtArgs> | null
    /**
     * Filter, which CkpScore to fetch.
     */
    where?: CkpScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CkpScores to fetch.
     */
    orderBy?: CkpScoreOrderByWithRelationInput | CkpScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CkpScores.
     */
    cursor?: CkpScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CkpScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CkpScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CkpScores.
     */
    distinct?: CkpScoreScalarFieldEnum | CkpScoreScalarFieldEnum[]
  }

  /**
   * CkpScore findMany
   */
  export type CkpScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreInclude<ExtArgs> | null
    /**
     * Filter, which CkpScores to fetch.
     */
    where?: CkpScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CkpScores to fetch.
     */
    orderBy?: CkpScoreOrderByWithRelationInput | CkpScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CkpScores.
     */
    cursor?: CkpScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CkpScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CkpScores.
     */
    skip?: number
    distinct?: CkpScoreScalarFieldEnum | CkpScoreScalarFieldEnum[]
  }

  /**
   * CkpScore create
   */
  export type CkpScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a CkpScore.
     */
    data: XOR<CkpScoreCreateInput, CkpScoreUncheckedCreateInput>
  }

  /**
   * CkpScore createMany
   */
  export type CkpScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CkpScores.
     */
    data: CkpScoreCreateManyInput | CkpScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CkpScore createManyAndReturn
   */
  export type CkpScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * The data used to create many CkpScores.
     */
    data: CkpScoreCreateManyInput | CkpScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CkpScore update
   */
  export type CkpScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a CkpScore.
     */
    data: XOR<CkpScoreUpdateInput, CkpScoreUncheckedUpdateInput>
    /**
     * Choose, which CkpScore to update.
     */
    where: CkpScoreWhereUniqueInput
  }

  /**
   * CkpScore updateMany
   */
  export type CkpScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CkpScores.
     */
    data: XOR<CkpScoreUpdateManyMutationInput, CkpScoreUncheckedUpdateManyInput>
    /**
     * Filter which CkpScores to update
     */
    where?: CkpScoreWhereInput
    /**
     * Limit how many CkpScores to update.
     */
    limit?: number
  }

  /**
   * CkpScore updateManyAndReturn
   */
  export type CkpScoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * The data used to update CkpScores.
     */
    data: XOR<CkpScoreUpdateManyMutationInput, CkpScoreUncheckedUpdateManyInput>
    /**
     * Filter which CkpScores to update
     */
    where?: CkpScoreWhereInput
    /**
     * Limit how many CkpScores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CkpScore upsert
   */
  export type CkpScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the CkpScore to update in case it exists.
     */
    where: CkpScoreWhereUniqueInput
    /**
     * In case the CkpScore found by the `where` argument doesn't exist, create a new CkpScore with this data.
     */
    create: XOR<CkpScoreCreateInput, CkpScoreUncheckedCreateInput>
    /**
     * In case the CkpScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CkpScoreUpdateInput, CkpScoreUncheckedUpdateInput>
  }

  /**
   * CkpScore delete
   */
  export type CkpScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreInclude<ExtArgs> | null
    /**
     * Filter which CkpScore to delete.
     */
    where: CkpScoreWhereUniqueInput
  }

  /**
   * CkpScore deleteMany
   */
  export type CkpScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CkpScores to delete
     */
    where?: CkpScoreWhereInput
    /**
     * Limit how many CkpScores to delete.
     */
    limit?: number
  }

  /**
   * CkpScore without action
   */
  export type CkpScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CkpScore
     */
    select?: CkpScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CkpScore
     */
    omit?: CkpScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CkpScoreInclude<ExtArgs> | null
  }


  /**
   * Model FinalEvaluation
   */

  export type AggregateFinalEvaluation = {
    _count: FinalEvaluationCountAggregateOutputType | null
    _avg: FinalEvaluationAvgAggregateOutputType | null
    _sum: FinalEvaluationSumAggregateOutputType | null
    _min: FinalEvaluationMinAggregateOutputType | null
    _max: FinalEvaluationMaxAggregateOutputType | null
  }

  export type FinalEvaluationAvgAggregateOutputType = {
    berakhlakScore: number | null
    presensiScore: number | null
    ckpScore: number | null
    finalScore: number | null
    totalEvaluators: number | null
    ranking: number | null
  }

  export type FinalEvaluationSumAggregateOutputType = {
    berakhlakScore: number | null
    presensiScore: number | null
    ckpScore: number | null
    finalScore: number | null
    totalEvaluators: number | null
    ranking: number | null
  }

  export type FinalEvaluationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    periodId: string | null
    berakhlakScore: number | null
    presensiScore: number | null
    ckpScore: number | null
    finalScore: number | null
    totalEvaluators: number | null
    ranking: number | null
    isBestEmployee: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinalEvaluationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    periodId: string | null
    berakhlakScore: number | null
    presensiScore: number | null
    ckpScore: number | null
    finalScore: number | null
    totalEvaluators: number | null
    ranking: number | null
    isBestEmployee: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinalEvaluationCountAggregateOutputType = {
    id: number
    userId: number
    periodId: number
    berakhlakScore: number
    presensiScore: number
    ckpScore: number
    finalScore: number
    totalEvaluators: number
    ranking: number
    isBestEmployee: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FinalEvaluationAvgAggregateInputType = {
    berakhlakScore?: true
    presensiScore?: true
    ckpScore?: true
    finalScore?: true
    totalEvaluators?: true
    ranking?: true
  }

  export type FinalEvaluationSumAggregateInputType = {
    berakhlakScore?: true
    presensiScore?: true
    ckpScore?: true
    finalScore?: true
    totalEvaluators?: true
    ranking?: true
  }

  export type FinalEvaluationMinAggregateInputType = {
    id?: true
    userId?: true
    periodId?: true
    berakhlakScore?: true
    presensiScore?: true
    ckpScore?: true
    finalScore?: true
    totalEvaluators?: true
    ranking?: true
    isBestEmployee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinalEvaluationMaxAggregateInputType = {
    id?: true
    userId?: true
    periodId?: true
    berakhlakScore?: true
    presensiScore?: true
    ckpScore?: true
    finalScore?: true
    totalEvaluators?: true
    ranking?: true
    isBestEmployee?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinalEvaluationCountAggregateInputType = {
    id?: true
    userId?: true
    periodId?: true
    berakhlakScore?: true
    presensiScore?: true
    ckpScore?: true
    finalScore?: true
    totalEvaluators?: true
    ranking?: true
    isBestEmployee?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FinalEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinalEvaluation to aggregate.
     */
    where?: FinalEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalEvaluations to fetch.
     */
    orderBy?: FinalEvaluationOrderByWithRelationInput | FinalEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinalEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinalEvaluations
    **/
    _count?: true | FinalEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinalEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinalEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinalEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinalEvaluationMaxAggregateInputType
  }

  export type GetFinalEvaluationAggregateType<T extends FinalEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateFinalEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinalEvaluation[P]>
      : GetScalarType<T[P], AggregateFinalEvaluation[P]>
  }




  export type FinalEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinalEvaluationWhereInput
    orderBy?: FinalEvaluationOrderByWithAggregationInput | FinalEvaluationOrderByWithAggregationInput[]
    by: FinalEvaluationScalarFieldEnum[] | FinalEvaluationScalarFieldEnum
    having?: FinalEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinalEvaluationCountAggregateInputType | true
    _avg?: FinalEvaluationAvgAggregateInputType
    _sum?: FinalEvaluationSumAggregateInputType
    _min?: FinalEvaluationMinAggregateInputType
    _max?: FinalEvaluationMaxAggregateInputType
  }

  export type FinalEvaluationGroupByOutputType = {
    id: string
    userId: string
    periodId: string
    berakhlakScore: number
    presensiScore: number
    ckpScore: number
    finalScore: number
    totalEvaluators: number
    ranking: number | null
    isBestEmployee: boolean
    createdAt: Date
    updatedAt: Date
    _count: FinalEvaluationCountAggregateOutputType | null
    _avg: FinalEvaluationAvgAggregateOutputType | null
    _sum: FinalEvaluationSumAggregateOutputType | null
    _min: FinalEvaluationMinAggregateOutputType | null
    _max: FinalEvaluationMaxAggregateOutputType | null
  }

  type GetFinalEvaluationGroupByPayload<T extends FinalEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinalEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinalEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinalEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], FinalEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type FinalEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    periodId?: boolean
    berakhlakScore?: boolean
    presensiScore?: boolean
    ckpScore?: boolean
    finalScore?: boolean
    totalEvaluators?: boolean
    ranking?: boolean
    isBestEmployee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finalEvaluation"]>

  export type FinalEvaluationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    periodId?: boolean
    berakhlakScore?: boolean
    presensiScore?: boolean
    ckpScore?: boolean
    finalScore?: boolean
    totalEvaluators?: boolean
    ranking?: boolean
    isBestEmployee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finalEvaluation"]>

  export type FinalEvaluationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    periodId?: boolean
    berakhlakScore?: boolean
    presensiScore?: boolean
    ckpScore?: boolean
    finalScore?: boolean
    totalEvaluators?: boolean
    ranking?: boolean
    isBestEmployee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["finalEvaluation"]>

  export type FinalEvaluationSelectScalar = {
    id?: boolean
    userId?: boolean
    periodId?: boolean
    berakhlakScore?: boolean
    presensiScore?: boolean
    ckpScore?: boolean
    finalScore?: boolean
    totalEvaluators?: boolean
    ranking?: boolean
    isBestEmployee?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FinalEvaluationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "periodId" | "berakhlakScore" | "presensiScore" | "ckpScore" | "finalScore" | "totalEvaluators" | "ranking" | "isBestEmployee" | "createdAt" | "updatedAt", ExtArgs["result"]["finalEvaluation"]>
  export type FinalEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }
  export type FinalEvaluationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }
  export type FinalEvaluationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    period?: boolean | PeriodDefaultArgs<ExtArgs>
  }

  export type $FinalEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinalEvaluation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      period: Prisma.$PeriodPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      periodId: string
      berakhlakScore: number
      presensiScore: number
      ckpScore: number
      finalScore: number
      totalEvaluators: number
      ranking: number | null
      isBestEmployee: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["finalEvaluation"]>
    composites: {}
  }

  type FinalEvaluationGetPayload<S extends boolean | null | undefined | FinalEvaluationDefaultArgs> = $Result.GetResult<Prisma.$FinalEvaluationPayload, S>

  type FinalEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FinalEvaluationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinalEvaluationCountAggregateInputType | true
    }

  export interface FinalEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinalEvaluation'], meta: { name: 'FinalEvaluation' } }
    /**
     * Find zero or one FinalEvaluation that matches the filter.
     * @param {FinalEvaluationFindUniqueArgs} args - Arguments to find a FinalEvaluation
     * @example
     * // Get one FinalEvaluation
     * const finalEvaluation = await prisma.finalEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinalEvaluationFindUniqueArgs>(args: SelectSubset<T, FinalEvaluationFindUniqueArgs<ExtArgs>>): Prisma__FinalEvaluationClient<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FinalEvaluation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FinalEvaluationFindUniqueOrThrowArgs} args - Arguments to find a FinalEvaluation
     * @example
     * // Get one FinalEvaluation
     * const finalEvaluation = await prisma.finalEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinalEvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, FinalEvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinalEvaluationClient<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinalEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalEvaluationFindFirstArgs} args - Arguments to find a FinalEvaluation
     * @example
     * // Get one FinalEvaluation
     * const finalEvaluation = await prisma.finalEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinalEvaluationFindFirstArgs>(args?: SelectSubset<T, FinalEvaluationFindFirstArgs<ExtArgs>>): Prisma__FinalEvaluationClient<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FinalEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalEvaluationFindFirstOrThrowArgs} args - Arguments to find a FinalEvaluation
     * @example
     * // Get one FinalEvaluation
     * const finalEvaluation = await prisma.finalEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinalEvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, FinalEvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinalEvaluationClient<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FinalEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalEvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinalEvaluations
     * const finalEvaluations = await prisma.finalEvaluation.findMany()
     * 
     * // Get first 10 FinalEvaluations
     * const finalEvaluations = await prisma.finalEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const finalEvaluationWithIdOnly = await prisma.finalEvaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinalEvaluationFindManyArgs>(args?: SelectSubset<T, FinalEvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FinalEvaluation.
     * @param {FinalEvaluationCreateArgs} args - Arguments to create a FinalEvaluation.
     * @example
     * // Create one FinalEvaluation
     * const FinalEvaluation = await prisma.finalEvaluation.create({
     *   data: {
     *     // ... data to create a FinalEvaluation
     *   }
     * })
     * 
     */
    create<T extends FinalEvaluationCreateArgs>(args: SelectSubset<T, FinalEvaluationCreateArgs<ExtArgs>>): Prisma__FinalEvaluationClient<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FinalEvaluations.
     * @param {FinalEvaluationCreateManyArgs} args - Arguments to create many FinalEvaluations.
     * @example
     * // Create many FinalEvaluations
     * const finalEvaluation = await prisma.finalEvaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinalEvaluationCreateManyArgs>(args?: SelectSubset<T, FinalEvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinalEvaluations and returns the data saved in the database.
     * @param {FinalEvaluationCreateManyAndReturnArgs} args - Arguments to create many FinalEvaluations.
     * @example
     * // Create many FinalEvaluations
     * const finalEvaluation = await prisma.finalEvaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinalEvaluations and only return the `id`
     * const finalEvaluationWithIdOnly = await prisma.finalEvaluation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinalEvaluationCreateManyAndReturnArgs>(args?: SelectSubset<T, FinalEvaluationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FinalEvaluation.
     * @param {FinalEvaluationDeleteArgs} args - Arguments to delete one FinalEvaluation.
     * @example
     * // Delete one FinalEvaluation
     * const FinalEvaluation = await prisma.finalEvaluation.delete({
     *   where: {
     *     // ... filter to delete one FinalEvaluation
     *   }
     * })
     * 
     */
    delete<T extends FinalEvaluationDeleteArgs>(args: SelectSubset<T, FinalEvaluationDeleteArgs<ExtArgs>>): Prisma__FinalEvaluationClient<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FinalEvaluation.
     * @param {FinalEvaluationUpdateArgs} args - Arguments to update one FinalEvaluation.
     * @example
     * // Update one FinalEvaluation
     * const finalEvaluation = await prisma.finalEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinalEvaluationUpdateArgs>(args: SelectSubset<T, FinalEvaluationUpdateArgs<ExtArgs>>): Prisma__FinalEvaluationClient<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FinalEvaluations.
     * @param {FinalEvaluationDeleteManyArgs} args - Arguments to filter FinalEvaluations to delete.
     * @example
     * // Delete a few FinalEvaluations
     * const { count } = await prisma.finalEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinalEvaluationDeleteManyArgs>(args?: SelectSubset<T, FinalEvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinalEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinalEvaluations
     * const finalEvaluation = await prisma.finalEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinalEvaluationUpdateManyArgs>(args: SelectSubset<T, FinalEvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinalEvaluations and returns the data updated in the database.
     * @param {FinalEvaluationUpdateManyAndReturnArgs} args - Arguments to update many FinalEvaluations.
     * @example
     * // Update many FinalEvaluations
     * const finalEvaluation = await prisma.finalEvaluation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FinalEvaluations and only return the `id`
     * const finalEvaluationWithIdOnly = await prisma.finalEvaluation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FinalEvaluationUpdateManyAndReturnArgs>(args: SelectSubset<T, FinalEvaluationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FinalEvaluation.
     * @param {FinalEvaluationUpsertArgs} args - Arguments to update or create a FinalEvaluation.
     * @example
     * // Update or create a FinalEvaluation
     * const finalEvaluation = await prisma.finalEvaluation.upsert({
     *   create: {
     *     // ... data to create a FinalEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinalEvaluation we want to update
     *   }
     * })
     */
    upsert<T extends FinalEvaluationUpsertArgs>(args: SelectSubset<T, FinalEvaluationUpsertArgs<ExtArgs>>): Prisma__FinalEvaluationClient<$Result.GetResult<Prisma.$FinalEvaluationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FinalEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalEvaluationCountArgs} args - Arguments to filter FinalEvaluations to count.
     * @example
     * // Count the number of FinalEvaluations
     * const count = await prisma.finalEvaluation.count({
     *   where: {
     *     // ... the filter for the FinalEvaluations we want to count
     *   }
     * })
    **/
    count<T extends FinalEvaluationCountArgs>(
      args?: Subset<T, FinalEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinalEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinalEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinalEvaluationAggregateArgs>(args: Subset<T, FinalEvaluationAggregateArgs>): Prisma.PrismaPromise<GetFinalEvaluationAggregateType<T>>

    /**
     * Group by FinalEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinalEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinalEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinalEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: FinalEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinalEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinalEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinalEvaluation model
   */
  readonly fields: FinalEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinalEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinalEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    period<T extends PeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PeriodDefaultArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinalEvaluation model
   */
  interface FinalEvaluationFieldRefs {
    readonly id: FieldRef<"FinalEvaluation", 'String'>
    readonly userId: FieldRef<"FinalEvaluation", 'String'>
    readonly periodId: FieldRef<"FinalEvaluation", 'String'>
    readonly berakhlakScore: FieldRef<"FinalEvaluation", 'Float'>
    readonly presensiScore: FieldRef<"FinalEvaluation", 'Float'>
    readonly ckpScore: FieldRef<"FinalEvaluation", 'Float'>
    readonly finalScore: FieldRef<"FinalEvaluation", 'Float'>
    readonly totalEvaluators: FieldRef<"FinalEvaluation", 'Int'>
    readonly ranking: FieldRef<"FinalEvaluation", 'Int'>
    readonly isBestEmployee: FieldRef<"FinalEvaluation", 'Boolean'>
    readonly createdAt: FieldRef<"FinalEvaluation", 'DateTime'>
    readonly updatedAt: FieldRef<"FinalEvaluation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FinalEvaluation findUnique
   */
  export type FinalEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which FinalEvaluation to fetch.
     */
    where: FinalEvaluationWhereUniqueInput
  }

  /**
   * FinalEvaluation findUniqueOrThrow
   */
  export type FinalEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which FinalEvaluation to fetch.
     */
    where: FinalEvaluationWhereUniqueInput
  }

  /**
   * FinalEvaluation findFirst
   */
  export type FinalEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which FinalEvaluation to fetch.
     */
    where?: FinalEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalEvaluations to fetch.
     */
    orderBy?: FinalEvaluationOrderByWithRelationInput | FinalEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinalEvaluations.
     */
    cursor?: FinalEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinalEvaluations.
     */
    distinct?: FinalEvaluationScalarFieldEnum | FinalEvaluationScalarFieldEnum[]
  }

  /**
   * FinalEvaluation findFirstOrThrow
   */
  export type FinalEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which FinalEvaluation to fetch.
     */
    where?: FinalEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalEvaluations to fetch.
     */
    orderBy?: FinalEvaluationOrderByWithRelationInput | FinalEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinalEvaluations.
     */
    cursor?: FinalEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinalEvaluations.
     */
    distinct?: FinalEvaluationScalarFieldEnum | FinalEvaluationScalarFieldEnum[]
  }

  /**
   * FinalEvaluation findMany
   */
  export type FinalEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which FinalEvaluations to fetch.
     */
    where?: FinalEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinalEvaluations to fetch.
     */
    orderBy?: FinalEvaluationOrderByWithRelationInput | FinalEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinalEvaluations.
     */
    cursor?: FinalEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinalEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinalEvaluations.
     */
    skip?: number
    distinct?: FinalEvaluationScalarFieldEnum | FinalEvaluationScalarFieldEnum[]
  }

  /**
   * FinalEvaluation create
   */
  export type FinalEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a FinalEvaluation.
     */
    data: XOR<FinalEvaluationCreateInput, FinalEvaluationUncheckedCreateInput>
  }

  /**
   * FinalEvaluation createMany
   */
  export type FinalEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinalEvaluations.
     */
    data: FinalEvaluationCreateManyInput | FinalEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinalEvaluation createManyAndReturn
   */
  export type FinalEvaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * The data used to create many FinalEvaluations.
     */
    data: FinalEvaluationCreateManyInput | FinalEvaluationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinalEvaluation update
   */
  export type FinalEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a FinalEvaluation.
     */
    data: XOR<FinalEvaluationUpdateInput, FinalEvaluationUncheckedUpdateInput>
    /**
     * Choose, which FinalEvaluation to update.
     */
    where: FinalEvaluationWhereUniqueInput
  }

  /**
   * FinalEvaluation updateMany
   */
  export type FinalEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinalEvaluations.
     */
    data: XOR<FinalEvaluationUpdateManyMutationInput, FinalEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which FinalEvaluations to update
     */
    where?: FinalEvaluationWhereInput
    /**
     * Limit how many FinalEvaluations to update.
     */
    limit?: number
  }

  /**
   * FinalEvaluation updateManyAndReturn
   */
  export type FinalEvaluationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * The data used to update FinalEvaluations.
     */
    data: XOR<FinalEvaluationUpdateManyMutationInput, FinalEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which FinalEvaluations to update
     */
    where?: FinalEvaluationWhereInput
    /**
     * Limit how many FinalEvaluations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinalEvaluation upsert
   */
  export type FinalEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the FinalEvaluation to update in case it exists.
     */
    where: FinalEvaluationWhereUniqueInput
    /**
     * In case the FinalEvaluation found by the `where` argument doesn't exist, create a new FinalEvaluation with this data.
     */
    create: XOR<FinalEvaluationCreateInput, FinalEvaluationUncheckedCreateInput>
    /**
     * In case the FinalEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinalEvaluationUpdateInput, FinalEvaluationUncheckedUpdateInput>
  }

  /**
   * FinalEvaluation delete
   */
  export type FinalEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationInclude<ExtArgs> | null
    /**
     * Filter which FinalEvaluation to delete.
     */
    where: FinalEvaluationWhereUniqueInput
  }

  /**
   * FinalEvaluation deleteMany
   */
  export type FinalEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinalEvaluations to delete
     */
    where?: FinalEvaluationWhereInput
    /**
     * Limit how many FinalEvaluations to delete.
     */
    limit?: number
  }

  /**
   * FinalEvaluation without action
   */
  export type FinalEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinalEvaluation
     */
    select?: FinalEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FinalEvaluation
     */
    omit?: FinalEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinalEvaluationInclude<ExtArgs> | null
  }


  /**
   * Model AspekPenilaian
   */

  export type AggregateAspekPenilaian = {
    _count: AspekPenilaianCountAggregateOutputType | null
    _avg: AspekPenilaianAvgAggregateOutputType | null
    _sum: AspekPenilaianSumAggregateOutputType | null
    _min: AspekPenilaianMinAggregateOutputType | null
    _max: AspekPenilaianMaxAggregateOutputType | null
  }

  export type AspekPenilaianAvgAggregateOutputType = {
    bobot: number | null
  }

  export type AspekPenilaianSumAggregateOutputType = {
    bobot: number | null
  }

  export type AspekPenilaianMinAggregateOutputType = {
    id: string | null
    namaAspek: string | null
    deskripsi: string | null
    kategori: string | null
    bobot: number | null
    createdAt: Date | null
  }

  export type AspekPenilaianMaxAggregateOutputType = {
    id: string | null
    namaAspek: string | null
    deskripsi: string | null
    kategori: string | null
    bobot: number | null
    createdAt: Date | null
  }

  export type AspekPenilaianCountAggregateOutputType = {
    id: number
    namaAspek: number
    deskripsi: number
    kategori: number
    bobot: number
    createdAt: number
    _all: number
  }


  export type AspekPenilaianAvgAggregateInputType = {
    bobot?: true
  }

  export type AspekPenilaianSumAggregateInputType = {
    bobot?: true
  }

  export type AspekPenilaianMinAggregateInputType = {
    id?: true
    namaAspek?: true
    deskripsi?: true
    kategori?: true
    bobot?: true
    createdAt?: true
  }

  export type AspekPenilaianMaxAggregateInputType = {
    id?: true
    namaAspek?: true
    deskripsi?: true
    kategori?: true
    bobot?: true
    createdAt?: true
  }

  export type AspekPenilaianCountAggregateInputType = {
    id?: true
    namaAspek?: true
    deskripsi?: true
    kategori?: true
    bobot?: true
    createdAt?: true
    _all?: true
  }

  export type AspekPenilaianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspekPenilaian to aggregate.
     */
    where?: AspekPenilaianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspekPenilaians to fetch.
     */
    orderBy?: AspekPenilaianOrderByWithRelationInput | AspekPenilaianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspekPenilaianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspekPenilaians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspekPenilaians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspekPenilaians
    **/
    _count?: true | AspekPenilaianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AspekPenilaianAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AspekPenilaianSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspekPenilaianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspekPenilaianMaxAggregateInputType
  }

  export type GetAspekPenilaianAggregateType<T extends AspekPenilaianAggregateArgs> = {
        [P in keyof T & keyof AggregateAspekPenilaian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspekPenilaian[P]>
      : GetScalarType<T[P], AggregateAspekPenilaian[P]>
  }




  export type AspekPenilaianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspekPenilaianWhereInput
    orderBy?: AspekPenilaianOrderByWithAggregationInput | AspekPenilaianOrderByWithAggregationInput[]
    by: AspekPenilaianScalarFieldEnum[] | AspekPenilaianScalarFieldEnum
    having?: AspekPenilaianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspekPenilaianCountAggregateInputType | true
    _avg?: AspekPenilaianAvgAggregateInputType
    _sum?: AspekPenilaianSumAggregateInputType
    _min?: AspekPenilaianMinAggregateInputType
    _max?: AspekPenilaianMaxAggregateInputType
  }

  export type AspekPenilaianGroupByOutputType = {
    id: string
    namaAspek: string
    deskripsi: string | null
    kategori: string | null
    bobot: number
    createdAt: Date
    _count: AspekPenilaianCountAggregateOutputType | null
    _avg: AspekPenilaianAvgAggregateOutputType | null
    _sum: AspekPenilaianSumAggregateOutputType | null
    _min: AspekPenilaianMinAggregateOutputType | null
    _max: AspekPenilaianMaxAggregateOutputType | null
  }

  type GetAspekPenilaianGroupByPayload<T extends AspekPenilaianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspekPenilaianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspekPenilaianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspekPenilaianGroupByOutputType[P]>
            : GetScalarType<T[P], AspekPenilaianGroupByOutputType[P]>
        }
      >
    >


  export type AspekPenilaianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namaAspek?: boolean
    deskripsi?: boolean
    kategori?: boolean
    bobot?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aspekPenilaian"]>

  export type AspekPenilaianSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namaAspek?: boolean
    deskripsi?: boolean
    kategori?: boolean
    bobot?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aspekPenilaian"]>

  export type AspekPenilaianSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namaAspek?: boolean
    deskripsi?: boolean
    kategori?: boolean
    bobot?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["aspekPenilaian"]>

  export type AspekPenilaianSelectScalar = {
    id?: boolean
    namaAspek?: boolean
    deskripsi?: boolean
    kategori?: boolean
    bobot?: boolean
    createdAt?: boolean
  }

  export type AspekPenilaianOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "namaAspek" | "deskripsi" | "kategori" | "bobot" | "createdAt", ExtArgs["result"]["aspekPenilaian"]>

  export type $AspekPenilaianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspekPenilaian"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      namaAspek: string
      deskripsi: string | null
      kategori: string | null
      bobot: number
      createdAt: Date
    }, ExtArgs["result"]["aspekPenilaian"]>
    composites: {}
  }

  type AspekPenilaianGetPayload<S extends boolean | null | undefined | AspekPenilaianDefaultArgs> = $Result.GetResult<Prisma.$AspekPenilaianPayload, S>

  type AspekPenilaianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AspekPenilaianFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AspekPenilaianCountAggregateInputType | true
    }

  export interface AspekPenilaianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspekPenilaian'], meta: { name: 'AspekPenilaian' } }
    /**
     * Find zero or one AspekPenilaian that matches the filter.
     * @param {AspekPenilaianFindUniqueArgs} args - Arguments to find a AspekPenilaian
     * @example
     * // Get one AspekPenilaian
     * const aspekPenilaian = await prisma.aspekPenilaian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspekPenilaianFindUniqueArgs>(args: SelectSubset<T, AspekPenilaianFindUniqueArgs<ExtArgs>>): Prisma__AspekPenilaianClient<$Result.GetResult<Prisma.$AspekPenilaianPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AspekPenilaian that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AspekPenilaianFindUniqueOrThrowArgs} args - Arguments to find a AspekPenilaian
     * @example
     * // Get one AspekPenilaian
     * const aspekPenilaian = await prisma.aspekPenilaian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspekPenilaianFindUniqueOrThrowArgs>(args: SelectSubset<T, AspekPenilaianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspekPenilaianClient<$Result.GetResult<Prisma.$AspekPenilaianPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspekPenilaian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspekPenilaianFindFirstArgs} args - Arguments to find a AspekPenilaian
     * @example
     * // Get one AspekPenilaian
     * const aspekPenilaian = await prisma.aspekPenilaian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspekPenilaianFindFirstArgs>(args?: SelectSubset<T, AspekPenilaianFindFirstArgs<ExtArgs>>): Prisma__AspekPenilaianClient<$Result.GetResult<Prisma.$AspekPenilaianPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspekPenilaian that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspekPenilaianFindFirstOrThrowArgs} args - Arguments to find a AspekPenilaian
     * @example
     * // Get one AspekPenilaian
     * const aspekPenilaian = await prisma.aspekPenilaian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspekPenilaianFindFirstOrThrowArgs>(args?: SelectSubset<T, AspekPenilaianFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspekPenilaianClient<$Result.GetResult<Prisma.$AspekPenilaianPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AspekPenilaians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspekPenilaianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspekPenilaians
     * const aspekPenilaians = await prisma.aspekPenilaian.findMany()
     * 
     * // Get first 10 AspekPenilaians
     * const aspekPenilaians = await prisma.aspekPenilaian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aspekPenilaianWithIdOnly = await prisma.aspekPenilaian.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AspekPenilaianFindManyArgs>(args?: SelectSubset<T, AspekPenilaianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspekPenilaianPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AspekPenilaian.
     * @param {AspekPenilaianCreateArgs} args - Arguments to create a AspekPenilaian.
     * @example
     * // Create one AspekPenilaian
     * const AspekPenilaian = await prisma.aspekPenilaian.create({
     *   data: {
     *     // ... data to create a AspekPenilaian
     *   }
     * })
     * 
     */
    create<T extends AspekPenilaianCreateArgs>(args: SelectSubset<T, AspekPenilaianCreateArgs<ExtArgs>>): Prisma__AspekPenilaianClient<$Result.GetResult<Prisma.$AspekPenilaianPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AspekPenilaians.
     * @param {AspekPenilaianCreateManyArgs} args - Arguments to create many AspekPenilaians.
     * @example
     * // Create many AspekPenilaians
     * const aspekPenilaian = await prisma.aspekPenilaian.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspekPenilaianCreateManyArgs>(args?: SelectSubset<T, AspekPenilaianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AspekPenilaians and returns the data saved in the database.
     * @param {AspekPenilaianCreateManyAndReturnArgs} args - Arguments to create many AspekPenilaians.
     * @example
     * // Create many AspekPenilaians
     * const aspekPenilaian = await prisma.aspekPenilaian.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AspekPenilaians and only return the `id`
     * const aspekPenilaianWithIdOnly = await prisma.aspekPenilaian.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AspekPenilaianCreateManyAndReturnArgs>(args?: SelectSubset<T, AspekPenilaianCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspekPenilaianPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AspekPenilaian.
     * @param {AspekPenilaianDeleteArgs} args - Arguments to delete one AspekPenilaian.
     * @example
     * // Delete one AspekPenilaian
     * const AspekPenilaian = await prisma.aspekPenilaian.delete({
     *   where: {
     *     // ... filter to delete one AspekPenilaian
     *   }
     * })
     * 
     */
    delete<T extends AspekPenilaianDeleteArgs>(args: SelectSubset<T, AspekPenilaianDeleteArgs<ExtArgs>>): Prisma__AspekPenilaianClient<$Result.GetResult<Prisma.$AspekPenilaianPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AspekPenilaian.
     * @param {AspekPenilaianUpdateArgs} args - Arguments to update one AspekPenilaian.
     * @example
     * // Update one AspekPenilaian
     * const aspekPenilaian = await prisma.aspekPenilaian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspekPenilaianUpdateArgs>(args: SelectSubset<T, AspekPenilaianUpdateArgs<ExtArgs>>): Prisma__AspekPenilaianClient<$Result.GetResult<Prisma.$AspekPenilaianPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AspekPenilaians.
     * @param {AspekPenilaianDeleteManyArgs} args - Arguments to filter AspekPenilaians to delete.
     * @example
     * // Delete a few AspekPenilaians
     * const { count } = await prisma.aspekPenilaian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspekPenilaianDeleteManyArgs>(args?: SelectSubset<T, AspekPenilaianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspekPenilaians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspekPenilaianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspekPenilaians
     * const aspekPenilaian = await prisma.aspekPenilaian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspekPenilaianUpdateManyArgs>(args: SelectSubset<T, AspekPenilaianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspekPenilaians and returns the data updated in the database.
     * @param {AspekPenilaianUpdateManyAndReturnArgs} args - Arguments to update many AspekPenilaians.
     * @example
     * // Update many AspekPenilaians
     * const aspekPenilaian = await prisma.aspekPenilaian.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AspekPenilaians and only return the `id`
     * const aspekPenilaianWithIdOnly = await prisma.aspekPenilaian.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AspekPenilaianUpdateManyAndReturnArgs>(args: SelectSubset<T, AspekPenilaianUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspekPenilaianPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AspekPenilaian.
     * @param {AspekPenilaianUpsertArgs} args - Arguments to update or create a AspekPenilaian.
     * @example
     * // Update or create a AspekPenilaian
     * const aspekPenilaian = await prisma.aspekPenilaian.upsert({
     *   create: {
     *     // ... data to create a AspekPenilaian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspekPenilaian we want to update
     *   }
     * })
     */
    upsert<T extends AspekPenilaianUpsertArgs>(args: SelectSubset<T, AspekPenilaianUpsertArgs<ExtArgs>>): Prisma__AspekPenilaianClient<$Result.GetResult<Prisma.$AspekPenilaianPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AspekPenilaians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspekPenilaianCountArgs} args - Arguments to filter AspekPenilaians to count.
     * @example
     * // Count the number of AspekPenilaians
     * const count = await prisma.aspekPenilaian.count({
     *   where: {
     *     // ... the filter for the AspekPenilaians we want to count
     *   }
     * })
    **/
    count<T extends AspekPenilaianCountArgs>(
      args?: Subset<T, AspekPenilaianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspekPenilaianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspekPenilaian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspekPenilaianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspekPenilaianAggregateArgs>(args: Subset<T, AspekPenilaianAggregateArgs>): Prisma.PrismaPromise<GetAspekPenilaianAggregateType<T>>

    /**
     * Group by AspekPenilaian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspekPenilaianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspekPenilaianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspekPenilaianGroupByArgs['orderBy'] }
        : { orderBy?: AspekPenilaianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspekPenilaianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspekPenilaianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspekPenilaian model
   */
  readonly fields: AspekPenilaianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspekPenilaian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspekPenilaianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspekPenilaian model
   */
  interface AspekPenilaianFieldRefs {
    readonly id: FieldRef<"AspekPenilaian", 'String'>
    readonly namaAspek: FieldRef<"AspekPenilaian", 'String'>
    readonly deskripsi: FieldRef<"AspekPenilaian", 'String'>
    readonly kategori: FieldRef<"AspekPenilaian", 'String'>
    readonly bobot: FieldRef<"AspekPenilaian", 'Float'>
    readonly createdAt: FieldRef<"AspekPenilaian", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AspekPenilaian findUnique
   */
  export type AspekPenilaianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspekPenilaian
     */
    select?: AspekPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspekPenilaian
     */
    omit?: AspekPenilaianOmit<ExtArgs> | null
    /**
     * Filter, which AspekPenilaian to fetch.
     */
    where: AspekPenilaianWhereUniqueInput
  }

  /**
   * AspekPenilaian findUniqueOrThrow
   */
  export type AspekPenilaianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspekPenilaian
     */
    select?: AspekPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspekPenilaian
     */
    omit?: AspekPenilaianOmit<ExtArgs> | null
    /**
     * Filter, which AspekPenilaian to fetch.
     */
    where: AspekPenilaianWhereUniqueInput
  }

  /**
   * AspekPenilaian findFirst
   */
  export type AspekPenilaianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspekPenilaian
     */
    select?: AspekPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspekPenilaian
     */
    omit?: AspekPenilaianOmit<ExtArgs> | null
    /**
     * Filter, which AspekPenilaian to fetch.
     */
    where?: AspekPenilaianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspekPenilaians to fetch.
     */
    orderBy?: AspekPenilaianOrderByWithRelationInput | AspekPenilaianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspekPenilaians.
     */
    cursor?: AspekPenilaianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspekPenilaians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspekPenilaians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspekPenilaians.
     */
    distinct?: AspekPenilaianScalarFieldEnum | AspekPenilaianScalarFieldEnum[]
  }

  /**
   * AspekPenilaian findFirstOrThrow
   */
  export type AspekPenilaianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspekPenilaian
     */
    select?: AspekPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspekPenilaian
     */
    omit?: AspekPenilaianOmit<ExtArgs> | null
    /**
     * Filter, which AspekPenilaian to fetch.
     */
    where?: AspekPenilaianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspekPenilaians to fetch.
     */
    orderBy?: AspekPenilaianOrderByWithRelationInput | AspekPenilaianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspekPenilaians.
     */
    cursor?: AspekPenilaianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspekPenilaians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspekPenilaians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspekPenilaians.
     */
    distinct?: AspekPenilaianScalarFieldEnum | AspekPenilaianScalarFieldEnum[]
  }

  /**
   * AspekPenilaian findMany
   */
  export type AspekPenilaianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspekPenilaian
     */
    select?: AspekPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspekPenilaian
     */
    omit?: AspekPenilaianOmit<ExtArgs> | null
    /**
     * Filter, which AspekPenilaians to fetch.
     */
    where?: AspekPenilaianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspekPenilaians to fetch.
     */
    orderBy?: AspekPenilaianOrderByWithRelationInput | AspekPenilaianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspekPenilaians.
     */
    cursor?: AspekPenilaianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspekPenilaians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspekPenilaians.
     */
    skip?: number
    distinct?: AspekPenilaianScalarFieldEnum | AspekPenilaianScalarFieldEnum[]
  }

  /**
   * AspekPenilaian create
   */
  export type AspekPenilaianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspekPenilaian
     */
    select?: AspekPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspekPenilaian
     */
    omit?: AspekPenilaianOmit<ExtArgs> | null
    /**
     * The data needed to create a AspekPenilaian.
     */
    data: XOR<AspekPenilaianCreateInput, AspekPenilaianUncheckedCreateInput>
  }

  /**
   * AspekPenilaian createMany
   */
  export type AspekPenilaianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspekPenilaians.
     */
    data: AspekPenilaianCreateManyInput | AspekPenilaianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AspekPenilaian createManyAndReturn
   */
  export type AspekPenilaianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspekPenilaian
     */
    select?: AspekPenilaianSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AspekPenilaian
     */
    omit?: AspekPenilaianOmit<ExtArgs> | null
    /**
     * The data used to create many AspekPenilaians.
     */
    data: AspekPenilaianCreateManyInput | AspekPenilaianCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AspekPenilaian update
   */
  export type AspekPenilaianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspekPenilaian
     */
    select?: AspekPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspekPenilaian
     */
    omit?: AspekPenilaianOmit<ExtArgs> | null
    /**
     * The data needed to update a AspekPenilaian.
     */
    data: XOR<AspekPenilaianUpdateInput, AspekPenilaianUncheckedUpdateInput>
    /**
     * Choose, which AspekPenilaian to update.
     */
    where: AspekPenilaianWhereUniqueInput
  }

  /**
   * AspekPenilaian updateMany
   */
  export type AspekPenilaianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspekPenilaians.
     */
    data: XOR<AspekPenilaianUpdateManyMutationInput, AspekPenilaianUncheckedUpdateManyInput>
    /**
     * Filter which AspekPenilaians to update
     */
    where?: AspekPenilaianWhereInput
    /**
     * Limit how many AspekPenilaians to update.
     */
    limit?: number
  }

  /**
   * AspekPenilaian updateManyAndReturn
   */
  export type AspekPenilaianUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspekPenilaian
     */
    select?: AspekPenilaianSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AspekPenilaian
     */
    omit?: AspekPenilaianOmit<ExtArgs> | null
    /**
     * The data used to update AspekPenilaians.
     */
    data: XOR<AspekPenilaianUpdateManyMutationInput, AspekPenilaianUncheckedUpdateManyInput>
    /**
     * Filter which AspekPenilaians to update
     */
    where?: AspekPenilaianWhereInput
    /**
     * Limit how many AspekPenilaians to update.
     */
    limit?: number
  }

  /**
   * AspekPenilaian upsert
   */
  export type AspekPenilaianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspekPenilaian
     */
    select?: AspekPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspekPenilaian
     */
    omit?: AspekPenilaianOmit<ExtArgs> | null
    /**
     * The filter to search for the AspekPenilaian to update in case it exists.
     */
    where: AspekPenilaianWhereUniqueInput
    /**
     * In case the AspekPenilaian found by the `where` argument doesn't exist, create a new AspekPenilaian with this data.
     */
    create: XOR<AspekPenilaianCreateInput, AspekPenilaianUncheckedCreateInput>
    /**
     * In case the AspekPenilaian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspekPenilaianUpdateInput, AspekPenilaianUncheckedUpdateInput>
  }

  /**
   * AspekPenilaian delete
   */
  export type AspekPenilaianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspekPenilaian
     */
    select?: AspekPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspekPenilaian
     */
    omit?: AspekPenilaianOmit<ExtArgs> | null
    /**
     * Filter which AspekPenilaian to delete.
     */
    where: AspekPenilaianWhereUniqueInput
  }

  /**
   * AspekPenilaian deleteMany
   */
  export type AspekPenilaianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspekPenilaians to delete
     */
    where?: AspekPenilaianWhereInput
    /**
     * Limit how many AspekPenilaians to delete.
     */
    limit?: number
  }

  /**
   * AspekPenilaian without action
   */
  export type AspekPenilaianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspekPenilaian
     */
    select?: AspekPenilaianSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspekPenilaian
     */
    omit?: AspekPenilaianOmit<ExtArgs> | null
  }


  /**
   * Model RentangNilai
   */

  export type AggregateRentangNilai = {
    _count: RentangNilaiCountAggregateOutputType | null
    _avg: RentangNilaiAvgAggregateOutputType | null
    _sum: RentangNilaiSumAggregateOutputType | null
    _min: RentangNilaiMinAggregateOutputType | null
    _max: RentangNilaiMaxAggregateOutputType | null
  }

  export type RentangNilaiAvgAggregateOutputType = {
    nilaiMin: number | null
    nilaiMax: number | null
  }

  export type RentangNilaiSumAggregateOutputType = {
    nilaiMin: number | null
    nilaiMax: number | null
  }

  export type RentangNilaiMinAggregateOutputType = {
    id: string | null
    kategori: string | null
    nilaiMin: number | null
    nilaiMax: number | null
    deskripsi: string | null
    createdAt: Date | null
  }

  export type RentangNilaiMaxAggregateOutputType = {
    id: string | null
    kategori: string | null
    nilaiMin: number | null
    nilaiMax: number | null
    deskripsi: string | null
    createdAt: Date | null
  }

  export type RentangNilaiCountAggregateOutputType = {
    id: number
    kategori: number
    nilaiMin: number
    nilaiMax: number
    deskripsi: number
    createdAt: number
    _all: number
  }


  export type RentangNilaiAvgAggregateInputType = {
    nilaiMin?: true
    nilaiMax?: true
  }

  export type RentangNilaiSumAggregateInputType = {
    nilaiMin?: true
    nilaiMax?: true
  }

  export type RentangNilaiMinAggregateInputType = {
    id?: true
    kategori?: true
    nilaiMin?: true
    nilaiMax?: true
    deskripsi?: true
    createdAt?: true
  }

  export type RentangNilaiMaxAggregateInputType = {
    id?: true
    kategori?: true
    nilaiMin?: true
    nilaiMax?: true
    deskripsi?: true
    createdAt?: true
  }

  export type RentangNilaiCountAggregateInputType = {
    id?: true
    kategori?: true
    nilaiMin?: true
    nilaiMax?: true
    deskripsi?: true
    createdAt?: true
    _all?: true
  }

  export type RentangNilaiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentangNilai to aggregate.
     */
    where?: RentangNilaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentangNilais to fetch.
     */
    orderBy?: RentangNilaiOrderByWithRelationInput | RentangNilaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RentangNilaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentangNilais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentangNilais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RentangNilais
    **/
    _count?: true | RentangNilaiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RentangNilaiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RentangNilaiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RentangNilaiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RentangNilaiMaxAggregateInputType
  }

  export type GetRentangNilaiAggregateType<T extends RentangNilaiAggregateArgs> = {
        [P in keyof T & keyof AggregateRentangNilai]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRentangNilai[P]>
      : GetScalarType<T[P], AggregateRentangNilai[P]>
  }




  export type RentangNilaiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentangNilaiWhereInput
    orderBy?: RentangNilaiOrderByWithAggregationInput | RentangNilaiOrderByWithAggregationInput[]
    by: RentangNilaiScalarFieldEnum[] | RentangNilaiScalarFieldEnum
    having?: RentangNilaiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RentangNilaiCountAggregateInputType | true
    _avg?: RentangNilaiAvgAggregateInputType
    _sum?: RentangNilaiSumAggregateInputType
    _min?: RentangNilaiMinAggregateInputType
    _max?: RentangNilaiMaxAggregateInputType
  }

  export type RentangNilaiGroupByOutputType = {
    id: string
    kategori: string
    nilaiMin: number
    nilaiMax: number
    deskripsi: string | null
    createdAt: Date
    _count: RentangNilaiCountAggregateOutputType | null
    _avg: RentangNilaiAvgAggregateOutputType | null
    _sum: RentangNilaiSumAggregateOutputType | null
    _min: RentangNilaiMinAggregateOutputType | null
    _max: RentangNilaiMaxAggregateOutputType | null
  }

  type GetRentangNilaiGroupByPayload<T extends RentangNilaiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RentangNilaiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RentangNilaiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RentangNilaiGroupByOutputType[P]>
            : GetScalarType<T[P], RentangNilaiGroupByOutputType[P]>
        }
      >
    >


  export type RentangNilaiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kategori?: boolean
    nilaiMin?: boolean
    nilaiMax?: boolean
    deskripsi?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rentangNilai"]>

  export type RentangNilaiSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kategori?: boolean
    nilaiMin?: boolean
    nilaiMax?: boolean
    deskripsi?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rentangNilai"]>

  export type RentangNilaiSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kategori?: boolean
    nilaiMin?: boolean
    nilaiMax?: boolean
    deskripsi?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rentangNilai"]>

  export type RentangNilaiSelectScalar = {
    id?: boolean
    kategori?: boolean
    nilaiMin?: boolean
    nilaiMax?: boolean
    deskripsi?: boolean
    createdAt?: boolean
  }

  export type RentangNilaiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kategori" | "nilaiMin" | "nilaiMax" | "deskripsi" | "createdAt", ExtArgs["result"]["rentangNilai"]>

  export type $RentangNilaiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RentangNilai"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kategori: string
      nilaiMin: number
      nilaiMax: number
      deskripsi: string | null
      createdAt: Date
    }, ExtArgs["result"]["rentangNilai"]>
    composites: {}
  }

  type RentangNilaiGetPayload<S extends boolean | null | undefined | RentangNilaiDefaultArgs> = $Result.GetResult<Prisma.$RentangNilaiPayload, S>

  type RentangNilaiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RentangNilaiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RentangNilaiCountAggregateInputType | true
    }

  export interface RentangNilaiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RentangNilai'], meta: { name: 'RentangNilai' } }
    /**
     * Find zero or one RentangNilai that matches the filter.
     * @param {RentangNilaiFindUniqueArgs} args - Arguments to find a RentangNilai
     * @example
     * // Get one RentangNilai
     * const rentangNilai = await prisma.rentangNilai.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RentangNilaiFindUniqueArgs>(args: SelectSubset<T, RentangNilaiFindUniqueArgs<ExtArgs>>): Prisma__RentangNilaiClient<$Result.GetResult<Prisma.$RentangNilaiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RentangNilai that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RentangNilaiFindUniqueOrThrowArgs} args - Arguments to find a RentangNilai
     * @example
     * // Get one RentangNilai
     * const rentangNilai = await prisma.rentangNilai.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RentangNilaiFindUniqueOrThrowArgs>(args: SelectSubset<T, RentangNilaiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RentangNilaiClient<$Result.GetResult<Prisma.$RentangNilaiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentangNilai that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentangNilaiFindFirstArgs} args - Arguments to find a RentangNilai
     * @example
     * // Get one RentangNilai
     * const rentangNilai = await prisma.rentangNilai.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RentangNilaiFindFirstArgs>(args?: SelectSubset<T, RentangNilaiFindFirstArgs<ExtArgs>>): Prisma__RentangNilaiClient<$Result.GetResult<Prisma.$RentangNilaiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentangNilai that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentangNilaiFindFirstOrThrowArgs} args - Arguments to find a RentangNilai
     * @example
     * // Get one RentangNilai
     * const rentangNilai = await prisma.rentangNilai.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RentangNilaiFindFirstOrThrowArgs>(args?: SelectSubset<T, RentangNilaiFindFirstOrThrowArgs<ExtArgs>>): Prisma__RentangNilaiClient<$Result.GetResult<Prisma.$RentangNilaiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RentangNilais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentangNilaiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RentangNilais
     * const rentangNilais = await prisma.rentangNilai.findMany()
     * 
     * // Get first 10 RentangNilais
     * const rentangNilais = await prisma.rentangNilai.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rentangNilaiWithIdOnly = await prisma.rentangNilai.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RentangNilaiFindManyArgs>(args?: SelectSubset<T, RentangNilaiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentangNilaiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RentangNilai.
     * @param {RentangNilaiCreateArgs} args - Arguments to create a RentangNilai.
     * @example
     * // Create one RentangNilai
     * const RentangNilai = await prisma.rentangNilai.create({
     *   data: {
     *     // ... data to create a RentangNilai
     *   }
     * })
     * 
     */
    create<T extends RentangNilaiCreateArgs>(args: SelectSubset<T, RentangNilaiCreateArgs<ExtArgs>>): Prisma__RentangNilaiClient<$Result.GetResult<Prisma.$RentangNilaiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RentangNilais.
     * @param {RentangNilaiCreateManyArgs} args - Arguments to create many RentangNilais.
     * @example
     * // Create many RentangNilais
     * const rentangNilai = await prisma.rentangNilai.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RentangNilaiCreateManyArgs>(args?: SelectSubset<T, RentangNilaiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RentangNilais and returns the data saved in the database.
     * @param {RentangNilaiCreateManyAndReturnArgs} args - Arguments to create many RentangNilais.
     * @example
     * // Create many RentangNilais
     * const rentangNilai = await prisma.rentangNilai.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RentangNilais and only return the `id`
     * const rentangNilaiWithIdOnly = await prisma.rentangNilai.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RentangNilaiCreateManyAndReturnArgs>(args?: SelectSubset<T, RentangNilaiCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentangNilaiPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RentangNilai.
     * @param {RentangNilaiDeleteArgs} args - Arguments to delete one RentangNilai.
     * @example
     * // Delete one RentangNilai
     * const RentangNilai = await prisma.rentangNilai.delete({
     *   where: {
     *     // ... filter to delete one RentangNilai
     *   }
     * })
     * 
     */
    delete<T extends RentangNilaiDeleteArgs>(args: SelectSubset<T, RentangNilaiDeleteArgs<ExtArgs>>): Prisma__RentangNilaiClient<$Result.GetResult<Prisma.$RentangNilaiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RentangNilai.
     * @param {RentangNilaiUpdateArgs} args - Arguments to update one RentangNilai.
     * @example
     * // Update one RentangNilai
     * const rentangNilai = await prisma.rentangNilai.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RentangNilaiUpdateArgs>(args: SelectSubset<T, RentangNilaiUpdateArgs<ExtArgs>>): Prisma__RentangNilaiClient<$Result.GetResult<Prisma.$RentangNilaiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RentangNilais.
     * @param {RentangNilaiDeleteManyArgs} args - Arguments to filter RentangNilais to delete.
     * @example
     * // Delete a few RentangNilais
     * const { count } = await prisma.rentangNilai.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RentangNilaiDeleteManyArgs>(args?: SelectSubset<T, RentangNilaiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentangNilais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentangNilaiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RentangNilais
     * const rentangNilai = await prisma.rentangNilai.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RentangNilaiUpdateManyArgs>(args: SelectSubset<T, RentangNilaiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentangNilais and returns the data updated in the database.
     * @param {RentangNilaiUpdateManyAndReturnArgs} args - Arguments to update many RentangNilais.
     * @example
     * // Update many RentangNilais
     * const rentangNilai = await prisma.rentangNilai.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RentangNilais and only return the `id`
     * const rentangNilaiWithIdOnly = await prisma.rentangNilai.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RentangNilaiUpdateManyAndReturnArgs>(args: SelectSubset<T, RentangNilaiUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentangNilaiPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RentangNilai.
     * @param {RentangNilaiUpsertArgs} args - Arguments to update or create a RentangNilai.
     * @example
     * // Update or create a RentangNilai
     * const rentangNilai = await prisma.rentangNilai.upsert({
     *   create: {
     *     // ... data to create a RentangNilai
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RentangNilai we want to update
     *   }
     * })
     */
    upsert<T extends RentangNilaiUpsertArgs>(args: SelectSubset<T, RentangNilaiUpsertArgs<ExtArgs>>): Prisma__RentangNilaiClient<$Result.GetResult<Prisma.$RentangNilaiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RentangNilais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentangNilaiCountArgs} args - Arguments to filter RentangNilais to count.
     * @example
     * // Count the number of RentangNilais
     * const count = await prisma.rentangNilai.count({
     *   where: {
     *     // ... the filter for the RentangNilais we want to count
     *   }
     * })
    **/
    count<T extends RentangNilaiCountArgs>(
      args?: Subset<T, RentangNilaiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RentangNilaiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RentangNilai.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentangNilaiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RentangNilaiAggregateArgs>(args: Subset<T, RentangNilaiAggregateArgs>): Prisma.PrismaPromise<GetRentangNilaiAggregateType<T>>

    /**
     * Group by RentangNilai.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentangNilaiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RentangNilaiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RentangNilaiGroupByArgs['orderBy'] }
        : { orderBy?: RentangNilaiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RentangNilaiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRentangNilaiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RentangNilai model
   */
  readonly fields: RentangNilaiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RentangNilai.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RentangNilaiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RentangNilai model
   */
  interface RentangNilaiFieldRefs {
    readonly id: FieldRef<"RentangNilai", 'String'>
    readonly kategori: FieldRef<"RentangNilai", 'String'>
    readonly nilaiMin: FieldRef<"RentangNilai", 'Int'>
    readonly nilaiMax: FieldRef<"RentangNilai", 'Int'>
    readonly deskripsi: FieldRef<"RentangNilai", 'String'>
    readonly createdAt: FieldRef<"RentangNilai", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RentangNilai findUnique
   */
  export type RentangNilaiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentangNilai
     */
    select?: RentangNilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentangNilai
     */
    omit?: RentangNilaiOmit<ExtArgs> | null
    /**
     * Filter, which RentangNilai to fetch.
     */
    where: RentangNilaiWhereUniqueInput
  }

  /**
   * RentangNilai findUniqueOrThrow
   */
  export type RentangNilaiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentangNilai
     */
    select?: RentangNilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentangNilai
     */
    omit?: RentangNilaiOmit<ExtArgs> | null
    /**
     * Filter, which RentangNilai to fetch.
     */
    where: RentangNilaiWhereUniqueInput
  }

  /**
   * RentangNilai findFirst
   */
  export type RentangNilaiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentangNilai
     */
    select?: RentangNilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentangNilai
     */
    omit?: RentangNilaiOmit<ExtArgs> | null
    /**
     * Filter, which RentangNilai to fetch.
     */
    where?: RentangNilaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentangNilais to fetch.
     */
    orderBy?: RentangNilaiOrderByWithRelationInput | RentangNilaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentangNilais.
     */
    cursor?: RentangNilaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentangNilais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentangNilais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentangNilais.
     */
    distinct?: RentangNilaiScalarFieldEnum | RentangNilaiScalarFieldEnum[]
  }

  /**
   * RentangNilai findFirstOrThrow
   */
  export type RentangNilaiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentangNilai
     */
    select?: RentangNilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentangNilai
     */
    omit?: RentangNilaiOmit<ExtArgs> | null
    /**
     * Filter, which RentangNilai to fetch.
     */
    where?: RentangNilaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentangNilais to fetch.
     */
    orderBy?: RentangNilaiOrderByWithRelationInput | RentangNilaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentangNilais.
     */
    cursor?: RentangNilaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentangNilais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentangNilais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentangNilais.
     */
    distinct?: RentangNilaiScalarFieldEnum | RentangNilaiScalarFieldEnum[]
  }

  /**
   * RentangNilai findMany
   */
  export type RentangNilaiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentangNilai
     */
    select?: RentangNilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentangNilai
     */
    omit?: RentangNilaiOmit<ExtArgs> | null
    /**
     * Filter, which RentangNilais to fetch.
     */
    where?: RentangNilaiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentangNilais to fetch.
     */
    orderBy?: RentangNilaiOrderByWithRelationInput | RentangNilaiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RentangNilais.
     */
    cursor?: RentangNilaiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentangNilais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentangNilais.
     */
    skip?: number
    distinct?: RentangNilaiScalarFieldEnum | RentangNilaiScalarFieldEnum[]
  }

  /**
   * RentangNilai create
   */
  export type RentangNilaiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentangNilai
     */
    select?: RentangNilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentangNilai
     */
    omit?: RentangNilaiOmit<ExtArgs> | null
    /**
     * The data needed to create a RentangNilai.
     */
    data: XOR<RentangNilaiCreateInput, RentangNilaiUncheckedCreateInput>
  }

  /**
   * RentangNilai createMany
   */
  export type RentangNilaiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RentangNilais.
     */
    data: RentangNilaiCreateManyInput | RentangNilaiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RentangNilai createManyAndReturn
   */
  export type RentangNilaiCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentangNilai
     */
    select?: RentangNilaiSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentangNilai
     */
    omit?: RentangNilaiOmit<ExtArgs> | null
    /**
     * The data used to create many RentangNilais.
     */
    data: RentangNilaiCreateManyInput | RentangNilaiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RentangNilai update
   */
  export type RentangNilaiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentangNilai
     */
    select?: RentangNilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentangNilai
     */
    omit?: RentangNilaiOmit<ExtArgs> | null
    /**
     * The data needed to update a RentangNilai.
     */
    data: XOR<RentangNilaiUpdateInput, RentangNilaiUncheckedUpdateInput>
    /**
     * Choose, which RentangNilai to update.
     */
    where: RentangNilaiWhereUniqueInput
  }

  /**
   * RentangNilai updateMany
   */
  export type RentangNilaiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RentangNilais.
     */
    data: XOR<RentangNilaiUpdateManyMutationInput, RentangNilaiUncheckedUpdateManyInput>
    /**
     * Filter which RentangNilais to update
     */
    where?: RentangNilaiWhereInput
    /**
     * Limit how many RentangNilais to update.
     */
    limit?: number
  }

  /**
   * RentangNilai updateManyAndReturn
   */
  export type RentangNilaiUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentangNilai
     */
    select?: RentangNilaiSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentangNilai
     */
    omit?: RentangNilaiOmit<ExtArgs> | null
    /**
     * The data used to update RentangNilais.
     */
    data: XOR<RentangNilaiUpdateManyMutationInput, RentangNilaiUncheckedUpdateManyInput>
    /**
     * Filter which RentangNilais to update
     */
    where?: RentangNilaiWhereInput
    /**
     * Limit how many RentangNilais to update.
     */
    limit?: number
  }

  /**
   * RentangNilai upsert
   */
  export type RentangNilaiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentangNilai
     */
    select?: RentangNilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentangNilai
     */
    omit?: RentangNilaiOmit<ExtArgs> | null
    /**
     * The filter to search for the RentangNilai to update in case it exists.
     */
    where: RentangNilaiWhereUniqueInput
    /**
     * In case the RentangNilai found by the `where` argument doesn't exist, create a new RentangNilai with this data.
     */
    create: XOR<RentangNilaiCreateInput, RentangNilaiUncheckedCreateInput>
    /**
     * In case the RentangNilai was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RentangNilaiUpdateInput, RentangNilaiUncheckedUpdateInput>
  }

  /**
   * RentangNilai delete
   */
  export type RentangNilaiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentangNilai
     */
    select?: RentangNilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentangNilai
     */
    omit?: RentangNilaiOmit<ExtArgs> | null
    /**
     * Filter which RentangNilai to delete.
     */
    where: RentangNilaiWhereUniqueInput
  }

  /**
   * RentangNilai deleteMany
   */
  export type RentangNilaiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentangNilais to delete
     */
    where?: RentangNilaiWhereInput
    /**
     * Limit how many RentangNilais to delete.
     */
    limit?: number
  }

  /**
   * RentangNilai without action
   */
  export type RentangNilaiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentangNilai
     */
    select?: RentangNilaiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentangNilai
     */
    omit?: RentangNilaiOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    nip: 'nip',
    nama: 'nama',
    email: 'email',
    password: 'password',
    role: 'role',
    jenisKelamin: 'jenisKelamin',
    tanggalLahir: 'tanggalLahir',
    alamat: 'alamat',
    mobilePhone: 'mobilePhone',
    pendidikanTerakhir: 'pendidikanTerakhir',
    jabatan: 'jabatan',
    golongan: 'golongan',
    status: 'status',
    instansi: 'instansi',
    kantor: 'kantor',
    username: 'username',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PeriodScalarFieldEnum: {
    id: 'id',
    tahun: 'tahun',
    bulan: 'bulan',
    namaPeriode: 'namaPeriode',
    noPeriode: 'noPeriode',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PeriodScalarFieldEnum = (typeof PeriodScalarFieldEnum)[keyof typeof PeriodScalarFieldEnum]


  export const EvaluationParameterScalarFieldEnum: {
    id: 'id',
    namaParameter: 'namaParameter',
    deskripsi: 'deskripsi',
    kategori: 'kategori',
    urutan: 'urutan',
    createdAt: 'createdAt'
  };

  export type EvaluationParameterScalarFieldEnum = (typeof EvaluationParameterScalarFieldEnum)[keyof typeof EvaluationParameterScalarFieldEnum]


  export const EvaluationScalarFieldEnum: {
    id: 'id',
    evaluatorId: 'evaluatorId',
    periodId: 'periodId',
    targetUserId: 'targetUserId',
    ranking: 'ranking',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvaluationScalarFieldEnum = (typeof EvaluationScalarFieldEnum)[keyof typeof EvaluationScalarFieldEnum]


  export const EvaluationScoreScalarFieldEnum: {
    id: 'id',
    evaluationId: 'evaluationId',
    parameterId: 'parameterId',
    score: 'score',
    createdAt: 'createdAt'
  };

  export type EvaluationScoreScalarFieldEnum = (typeof EvaluationScoreScalarFieldEnum)[keyof typeof EvaluationScoreScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    periodId: 'periodId',
    persentaseTotal: 'persentaseTotal',
    tidakKerja: 'tidakKerja',
    pulangAwal: 'pulangAwal',
    telat: 'telat',
    absenApel: 'absenApel',
    cuti: 'cuti',
    totalMinus: 'totalMinus',
    nilaiPresensi: 'nilaiPresensi',
    keterangan: 'keterangan',
    inputBy: 'inputBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const CkpScoreScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    periodId: 'periodId',
    score: 'score',
    keterangan: 'keterangan',
    inputBy: 'inputBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CkpScoreScalarFieldEnum = (typeof CkpScoreScalarFieldEnum)[keyof typeof CkpScoreScalarFieldEnum]


  export const FinalEvaluationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    periodId: 'periodId',
    berakhlakScore: 'berakhlakScore',
    presensiScore: 'presensiScore',
    ckpScore: 'ckpScore',
    finalScore: 'finalScore',
    totalEvaluators: 'totalEvaluators',
    ranking: 'ranking',
    isBestEmployee: 'isBestEmployee',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FinalEvaluationScalarFieldEnum = (typeof FinalEvaluationScalarFieldEnum)[keyof typeof FinalEvaluationScalarFieldEnum]


  export const AspekPenilaianScalarFieldEnum: {
    id: 'id',
    namaAspek: 'namaAspek',
    deskripsi: 'deskripsi',
    kategori: 'kategori',
    bobot: 'bobot',
    createdAt: 'createdAt'
  };

  export type AspekPenilaianScalarFieldEnum = (typeof AspekPenilaianScalarFieldEnum)[keyof typeof AspekPenilaianScalarFieldEnum]


  export const RentangNilaiScalarFieldEnum: {
    id: 'id',
    kategori: 'kategori',
    nilaiMin: 'nilaiMin',
    nilaiMax: 'nilaiMax',
    deskripsi: 'deskripsi',
    createdAt: 'createdAt'
  };

  export type RentangNilaiScalarFieldEnum = (typeof RentangNilaiScalarFieldEnum)[keyof typeof RentangNilaiScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'EvaluationStatus'
   */
  export type EnumEvaluationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvaluationStatus'>
    


  /**
   * Reference to a field of type 'EvaluationStatus[]'
   */
  export type ListEnumEvaluationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvaluationStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    nip?: StringFilter<"User"> | string
    nama?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    jenisKelamin?: EnumGenderFilter<"User"> | $Enums.Gender
    tanggalLahir?: DateTimeNullableFilter<"User"> | Date | string | null
    alamat?: StringNullableFilter<"User"> | string | null
    mobilePhone?: StringNullableFilter<"User"> | string | null
    pendidikanTerakhir?: StringNullableFilter<"User"> | string | null
    jabatan?: StringNullableFilter<"User"> | string | null
    golongan?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    instansi?: StringNullableFilter<"User"> | string | null
    kantor?: StringNullableFilter<"User"> | string | null
    username?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    evaluationsGiven?: EvaluationListRelationFilter
    evaluationsReceived?: EvaluationListRelationFilter
    attendances?: AttendanceListRelationFilter
    ckpScores?: CkpScoreListRelationFilter
    finalEvaluations?: FinalEvaluationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    nip?: SortOrder
    nama?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    jenisKelamin?: SortOrder
    tanggalLahir?: SortOrderInput | SortOrder
    alamat?: SortOrderInput | SortOrder
    mobilePhone?: SortOrderInput | SortOrder
    pendidikanTerakhir?: SortOrderInput | SortOrder
    jabatan?: SortOrderInput | SortOrder
    golongan?: SortOrderInput | SortOrder
    status?: SortOrder
    instansi?: SortOrderInput | SortOrder
    kantor?: SortOrderInput | SortOrder
    username?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluationsGiven?: EvaluationOrderByRelationAggregateInput
    evaluationsReceived?: EvaluationOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    ckpScores?: CkpScoreOrderByRelationAggregateInput
    finalEvaluations?: FinalEvaluationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nip?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    nama?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    jenisKelamin?: EnumGenderFilter<"User"> | $Enums.Gender
    tanggalLahir?: DateTimeNullableFilter<"User"> | Date | string | null
    alamat?: StringNullableFilter<"User"> | string | null
    mobilePhone?: StringNullableFilter<"User"> | string | null
    pendidikanTerakhir?: StringNullableFilter<"User"> | string | null
    jabatan?: StringNullableFilter<"User"> | string | null
    golongan?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    instansi?: StringNullableFilter<"User"> | string | null
    kantor?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    evaluationsGiven?: EvaluationListRelationFilter
    evaluationsReceived?: EvaluationListRelationFilter
    attendances?: AttendanceListRelationFilter
    ckpScores?: CkpScoreListRelationFilter
    finalEvaluations?: FinalEvaluationListRelationFilter
  }, "id" | "nip" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    nip?: SortOrder
    nama?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    jenisKelamin?: SortOrder
    tanggalLahir?: SortOrderInput | SortOrder
    alamat?: SortOrderInput | SortOrder
    mobilePhone?: SortOrderInput | SortOrder
    pendidikanTerakhir?: SortOrderInput | SortOrder
    jabatan?: SortOrderInput | SortOrder
    golongan?: SortOrderInput | SortOrder
    status?: SortOrder
    instansi?: SortOrderInput | SortOrder
    kantor?: SortOrderInput | SortOrder
    username?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    nip?: StringWithAggregatesFilter<"User"> | string
    nama?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    jenisKelamin?: EnumGenderWithAggregatesFilter<"User"> | $Enums.Gender
    tanggalLahir?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    alamat?: StringNullableWithAggregatesFilter<"User"> | string | null
    mobilePhone?: StringNullableWithAggregatesFilter<"User"> | string | null
    pendidikanTerakhir?: StringNullableWithAggregatesFilter<"User"> | string | null
    jabatan?: StringNullableWithAggregatesFilter<"User"> | string | null
    golongan?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: StringWithAggregatesFilter<"User"> | string
    instansi?: StringNullableWithAggregatesFilter<"User"> | string | null
    kantor?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PeriodWhereInput = {
    AND?: PeriodWhereInput | PeriodWhereInput[]
    OR?: PeriodWhereInput[]
    NOT?: PeriodWhereInput | PeriodWhereInput[]
    id?: StringFilter<"Period"> | string
    tahun?: IntFilter<"Period"> | number
    bulan?: IntFilter<"Period"> | number
    namaPeriode?: StringFilter<"Period"> | string
    noPeriode?: IntNullableFilter<"Period"> | number | null
    isActive?: BoolFilter<"Period"> | boolean
    createdAt?: DateTimeFilter<"Period"> | Date | string
    updatedAt?: DateTimeFilter<"Period"> | Date | string
    evaluations?: EvaluationListRelationFilter
    attendances?: AttendanceListRelationFilter
    ckpScores?: CkpScoreListRelationFilter
    finalEvaluations?: FinalEvaluationListRelationFilter
  }

  export type PeriodOrderByWithRelationInput = {
    id?: SortOrder
    tahun?: SortOrder
    bulan?: SortOrder
    namaPeriode?: SortOrder
    noPeriode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluations?: EvaluationOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    ckpScores?: CkpScoreOrderByRelationAggregateInput
    finalEvaluations?: FinalEvaluationOrderByRelationAggregateInput
  }

  export type PeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tahun_bulan?: PeriodTahunBulanCompoundUniqueInput
    AND?: PeriodWhereInput | PeriodWhereInput[]
    OR?: PeriodWhereInput[]
    NOT?: PeriodWhereInput | PeriodWhereInput[]
    tahun?: IntFilter<"Period"> | number
    bulan?: IntFilter<"Period"> | number
    namaPeriode?: StringFilter<"Period"> | string
    noPeriode?: IntNullableFilter<"Period"> | number | null
    isActive?: BoolFilter<"Period"> | boolean
    createdAt?: DateTimeFilter<"Period"> | Date | string
    updatedAt?: DateTimeFilter<"Period"> | Date | string
    evaluations?: EvaluationListRelationFilter
    attendances?: AttendanceListRelationFilter
    ckpScores?: CkpScoreListRelationFilter
    finalEvaluations?: FinalEvaluationListRelationFilter
  }, "id" | "tahun_bulan">

  export type PeriodOrderByWithAggregationInput = {
    id?: SortOrder
    tahun?: SortOrder
    bulan?: SortOrder
    namaPeriode?: SortOrder
    noPeriode?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PeriodCountOrderByAggregateInput
    _avg?: PeriodAvgOrderByAggregateInput
    _max?: PeriodMaxOrderByAggregateInput
    _min?: PeriodMinOrderByAggregateInput
    _sum?: PeriodSumOrderByAggregateInput
  }

  export type PeriodScalarWhereWithAggregatesInput = {
    AND?: PeriodScalarWhereWithAggregatesInput | PeriodScalarWhereWithAggregatesInput[]
    OR?: PeriodScalarWhereWithAggregatesInput[]
    NOT?: PeriodScalarWhereWithAggregatesInput | PeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Period"> | string
    tahun?: IntWithAggregatesFilter<"Period"> | number
    bulan?: IntWithAggregatesFilter<"Period"> | number
    namaPeriode?: StringWithAggregatesFilter<"Period"> | string
    noPeriode?: IntNullableWithAggregatesFilter<"Period"> | number | null
    isActive?: BoolWithAggregatesFilter<"Period"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Period"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Period"> | Date | string
  }

  export type EvaluationParameterWhereInput = {
    AND?: EvaluationParameterWhereInput | EvaluationParameterWhereInput[]
    OR?: EvaluationParameterWhereInput[]
    NOT?: EvaluationParameterWhereInput | EvaluationParameterWhereInput[]
    id?: StringFilter<"EvaluationParameter"> | string
    namaParameter?: StringFilter<"EvaluationParameter"> | string
    deskripsi?: StringNullableFilter<"EvaluationParameter"> | string | null
    kategori?: StringFilter<"EvaluationParameter"> | string
    urutan?: IntFilter<"EvaluationParameter"> | number
    createdAt?: DateTimeFilter<"EvaluationParameter"> | Date | string
    evaluationScores?: EvaluationScoreListRelationFilter
  }

  export type EvaluationParameterOrderByWithRelationInput = {
    id?: SortOrder
    namaParameter?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    kategori?: SortOrder
    urutan?: SortOrder
    createdAt?: SortOrder
    evaluationScores?: EvaluationScoreOrderByRelationAggregateInput
  }

  export type EvaluationParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvaluationParameterWhereInput | EvaluationParameterWhereInput[]
    OR?: EvaluationParameterWhereInput[]
    NOT?: EvaluationParameterWhereInput | EvaluationParameterWhereInput[]
    namaParameter?: StringFilter<"EvaluationParameter"> | string
    deskripsi?: StringNullableFilter<"EvaluationParameter"> | string | null
    kategori?: StringFilter<"EvaluationParameter"> | string
    urutan?: IntFilter<"EvaluationParameter"> | number
    createdAt?: DateTimeFilter<"EvaluationParameter"> | Date | string
    evaluationScores?: EvaluationScoreListRelationFilter
  }, "id">

  export type EvaluationParameterOrderByWithAggregationInput = {
    id?: SortOrder
    namaParameter?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    kategori?: SortOrder
    urutan?: SortOrder
    createdAt?: SortOrder
    _count?: EvaluationParameterCountOrderByAggregateInput
    _avg?: EvaluationParameterAvgOrderByAggregateInput
    _max?: EvaluationParameterMaxOrderByAggregateInput
    _min?: EvaluationParameterMinOrderByAggregateInput
    _sum?: EvaluationParameterSumOrderByAggregateInput
  }

  export type EvaluationParameterScalarWhereWithAggregatesInput = {
    AND?: EvaluationParameterScalarWhereWithAggregatesInput | EvaluationParameterScalarWhereWithAggregatesInput[]
    OR?: EvaluationParameterScalarWhereWithAggregatesInput[]
    NOT?: EvaluationParameterScalarWhereWithAggregatesInput | EvaluationParameterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvaluationParameter"> | string
    namaParameter?: StringWithAggregatesFilter<"EvaluationParameter"> | string
    deskripsi?: StringNullableWithAggregatesFilter<"EvaluationParameter"> | string | null
    kategori?: StringWithAggregatesFilter<"EvaluationParameter"> | string
    urutan?: IntWithAggregatesFilter<"EvaluationParameter"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EvaluationParameter"> | Date | string
  }

  export type EvaluationWhereInput = {
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    id?: StringFilter<"Evaluation"> | string
    evaluatorId?: StringFilter<"Evaluation"> | string
    periodId?: StringFilter<"Evaluation"> | string
    targetUserId?: StringFilter<"Evaluation"> | string
    ranking?: IntFilter<"Evaluation"> | number
    status?: EnumEvaluationStatusFilter<"Evaluation"> | $Enums.EvaluationStatus
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeFilter<"Evaluation"> | Date | string
    evaluator?: XOR<UserScalarRelationFilter, UserWhereInput>
    target?: XOR<UserScalarRelationFilter, UserWhereInput>
    period?: XOR<PeriodScalarRelationFilter, PeriodWhereInput>
    scores?: EvaluationScoreListRelationFilter
  }

  export type EvaluationOrderByWithRelationInput = {
    id?: SortOrder
    evaluatorId?: SortOrder
    periodId?: SortOrder
    targetUserId?: SortOrder
    ranking?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluator?: UserOrderByWithRelationInput
    target?: UserOrderByWithRelationInput
    period?: PeriodOrderByWithRelationInput
    scores?: EvaluationScoreOrderByRelationAggregateInput
  }

  export type EvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    evaluatorId_periodId_targetUserId?: EvaluationEvaluatorIdPeriodIdTargetUserIdCompoundUniqueInput
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    evaluatorId?: StringFilter<"Evaluation"> | string
    periodId?: StringFilter<"Evaluation"> | string
    targetUserId?: StringFilter<"Evaluation"> | string
    ranking?: IntFilter<"Evaluation"> | number
    status?: EnumEvaluationStatusFilter<"Evaluation"> | $Enums.EvaluationStatus
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeFilter<"Evaluation"> | Date | string
    evaluator?: XOR<UserScalarRelationFilter, UserWhereInput>
    target?: XOR<UserScalarRelationFilter, UserWhereInput>
    period?: XOR<PeriodScalarRelationFilter, PeriodWhereInput>
    scores?: EvaluationScoreListRelationFilter
  }, "id" | "evaluatorId_periodId_targetUserId">

  export type EvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    evaluatorId?: SortOrder
    periodId?: SortOrder
    targetUserId?: SortOrder
    ranking?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvaluationCountOrderByAggregateInput
    _avg?: EvaluationAvgOrderByAggregateInput
    _max?: EvaluationMaxOrderByAggregateInput
    _min?: EvaluationMinOrderByAggregateInput
    _sum?: EvaluationSumOrderByAggregateInput
  }

  export type EvaluationScalarWhereWithAggregatesInput = {
    AND?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    OR?: EvaluationScalarWhereWithAggregatesInput[]
    NOT?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evaluation"> | string
    evaluatorId?: StringWithAggregatesFilter<"Evaluation"> | string
    periodId?: StringWithAggregatesFilter<"Evaluation"> | string
    targetUserId?: StringWithAggregatesFilter<"Evaluation"> | string
    ranking?: IntWithAggregatesFilter<"Evaluation"> | number
    status?: EnumEvaluationStatusWithAggregatesFilter<"Evaluation"> | $Enums.EvaluationStatus
    createdAt?: DateTimeWithAggregatesFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Evaluation"> | Date | string
  }

  export type EvaluationScoreWhereInput = {
    AND?: EvaluationScoreWhereInput | EvaluationScoreWhereInput[]
    OR?: EvaluationScoreWhereInput[]
    NOT?: EvaluationScoreWhereInput | EvaluationScoreWhereInput[]
    id?: StringFilter<"EvaluationScore"> | string
    evaluationId?: StringFilter<"EvaluationScore"> | string
    parameterId?: StringFilter<"EvaluationScore"> | string
    score?: IntFilter<"EvaluationScore"> | number
    createdAt?: DateTimeFilter<"EvaluationScore"> | Date | string
    evaluation?: XOR<EvaluationScalarRelationFilter, EvaluationWhereInput>
    parameter?: XOR<EvaluationParameterScalarRelationFilter, EvaluationParameterWhereInput>
  }

  export type EvaluationScoreOrderByWithRelationInput = {
    id?: SortOrder
    evaluationId?: SortOrder
    parameterId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    evaluation?: EvaluationOrderByWithRelationInput
    parameter?: EvaluationParameterOrderByWithRelationInput
  }

  export type EvaluationScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    evaluationId_parameterId?: EvaluationScoreEvaluationIdParameterIdCompoundUniqueInput
    AND?: EvaluationScoreWhereInput | EvaluationScoreWhereInput[]
    OR?: EvaluationScoreWhereInput[]
    NOT?: EvaluationScoreWhereInput | EvaluationScoreWhereInput[]
    evaluationId?: StringFilter<"EvaluationScore"> | string
    parameterId?: StringFilter<"EvaluationScore"> | string
    score?: IntFilter<"EvaluationScore"> | number
    createdAt?: DateTimeFilter<"EvaluationScore"> | Date | string
    evaluation?: XOR<EvaluationScalarRelationFilter, EvaluationWhereInput>
    parameter?: XOR<EvaluationParameterScalarRelationFilter, EvaluationParameterWhereInput>
  }, "id" | "evaluationId_parameterId">

  export type EvaluationScoreOrderByWithAggregationInput = {
    id?: SortOrder
    evaluationId?: SortOrder
    parameterId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    _count?: EvaluationScoreCountOrderByAggregateInput
    _avg?: EvaluationScoreAvgOrderByAggregateInput
    _max?: EvaluationScoreMaxOrderByAggregateInput
    _min?: EvaluationScoreMinOrderByAggregateInput
    _sum?: EvaluationScoreSumOrderByAggregateInput
  }

  export type EvaluationScoreScalarWhereWithAggregatesInput = {
    AND?: EvaluationScoreScalarWhereWithAggregatesInput | EvaluationScoreScalarWhereWithAggregatesInput[]
    OR?: EvaluationScoreScalarWhereWithAggregatesInput[]
    NOT?: EvaluationScoreScalarWhereWithAggregatesInput | EvaluationScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvaluationScore"> | string
    evaluationId?: StringWithAggregatesFilter<"EvaluationScore"> | string
    parameterId?: StringWithAggregatesFilter<"EvaluationScore"> | string
    score?: IntWithAggregatesFilter<"EvaluationScore"> | number
    createdAt?: DateTimeWithAggregatesFilter<"EvaluationScore"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    userId?: StringFilter<"Attendance"> | string
    periodId?: StringFilter<"Attendance"> | string
    persentaseTotal?: FloatFilter<"Attendance"> | number
    tidakKerja?: FloatFilter<"Attendance"> | number
    pulangAwal?: FloatFilter<"Attendance"> | number
    telat?: FloatFilter<"Attendance"> | number
    absenApel?: FloatFilter<"Attendance"> | number
    cuti?: FloatFilter<"Attendance"> | number
    totalMinus?: FloatFilter<"Attendance"> | number
    nilaiPresensi?: FloatFilter<"Attendance"> | number
    keterangan?: StringNullableFilter<"Attendance"> | string | null
    inputBy?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    period?: XOR<PeriodScalarRelationFilter, PeriodWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    persentaseTotal?: SortOrder
    tidakKerja?: SortOrder
    pulangAwal?: SortOrder
    telat?: SortOrder
    absenApel?: SortOrder
    cuti?: SortOrder
    totalMinus?: SortOrder
    nilaiPresensi?: SortOrder
    keterangan?: SortOrderInput | SortOrder
    inputBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    period?: PeriodOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_periodId?: AttendanceUserIdPeriodIdCompoundUniqueInput
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    userId?: StringFilter<"Attendance"> | string
    periodId?: StringFilter<"Attendance"> | string
    persentaseTotal?: FloatFilter<"Attendance"> | number
    tidakKerja?: FloatFilter<"Attendance"> | number
    pulangAwal?: FloatFilter<"Attendance"> | number
    telat?: FloatFilter<"Attendance"> | number
    absenApel?: FloatFilter<"Attendance"> | number
    cuti?: FloatFilter<"Attendance"> | number
    totalMinus?: FloatFilter<"Attendance"> | number
    nilaiPresensi?: FloatFilter<"Attendance"> | number
    keterangan?: StringNullableFilter<"Attendance"> | string | null
    inputBy?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    period?: XOR<PeriodScalarRelationFilter, PeriodWhereInput>
  }, "id" | "userId_periodId">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    persentaseTotal?: SortOrder
    tidakKerja?: SortOrder
    pulangAwal?: SortOrder
    telat?: SortOrder
    absenApel?: SortOrder
    cuti?: SortOrder
    totalMinus?: SortOrder
    nilaiPresensi?: SortOrder
    keterangan?: SortOrderInput | SortOrder
    inputBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _avg?: AttendanceAvgOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
    _sum?: AttendanceSumOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    userId?: StringWithAggregatesFilter<"Attendance"> | string
    periodId?: StringWithAggregatesFilter<"Attendance"> | string
    persentaseTotal?: FloatWithAggregatesFilter<"Attendance"> | number
    tidakKerja?: FloatWithAggregatesFilter<"Attendance"> | number
    pulangAwal?: FloatWithAggregatesFilter<"Attendance"> | number
    telat?: FloatWithAggregatesFilter<"Attendance"> | number
    absenApel?: FloatWithAggregatesFilter<"Attendance"> | number
    cuti?: FloatWithAggregatesFilter<"Attendance"> | number
    totalMinus?: FloatWithAggregatesFilter<"Attendance"> | number
    nilaiPresensi?: FloatWithAggregatesFilter<"Attendance"> | number
    keterangan?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    inputBy?: StringWithAggregatesFilter<"Attendance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type CkpScoreWhereInput = {
    AND?: CkpScoreWhereInput | CkpScoreWhereInput[]
    OR?: CkpScoreWhereInput[]
    NOT?: CkpScoreWhereInput | CkpScoreWhereInput[]
    id?: StringFilter<"CkpScore"> | string
    userId?: StringFilter<"CkpScore"> | string
    periodId?: StringFilter<"CkpScore"> | string
    score?: FloatFilter<"CkpScore"> | number
    keterangan?: StringNullableFilter<"CkpScore"> | string | null
    inputBy?: StringFilter<"CkpScore"> | string
    createdAt?: DateTimeFilter<"CkpScore"> | Date | string
    updatedAt?: DateTimeFilter<"CkpScore"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    period?: XOR<PeriodScalarRelationFilter, PeriodWhereInput>
  }

  export type CkpScoreOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    score?: SortOrder
    keterangan?: SortOrderInput | SortOrder
    inputBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    period?: PeriodOrderByWithRelationInput
  }

  export type CkpScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_periodId?: CkpScoreUserIdPeriodIdCompoundUniqueInput
    AND?: CkpScoreWhereInput | CkpScoreWhereInput[]
    OR?: CkpScoreWhereInput[]
    NOT?: CkpScoreWhereInput | CkpScoreWhereInput[]
    userId?: StringFilter<"CkpScore"> | string
    periodId?: StringFilter<"CkpScore"> | string
    score?: FloatFilter<"CkpScore"> | number
    keterangan?: StringNullableFilter<"CkpScore"> | string | null
    inputBy?: StringFilter<"CkpScore"> | string
    createdAt?: DateTimeFilter<"CkpScore"> | Date | string
    updatedAt?: DateTimeFilter<"CkpScore"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    period?: XOR<PeriodScalarRelationFilter, PeriodWhereInput>
  }, "id" | "userId_periodId">

  export type CkpScoreOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    score?: SortOrder
    keterangan?: SortOrderInput | SortOrder
    inputBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CkpScoreCountOrderByAggregateInput
    _avg?: CkpScoreAvgOrderByAggregateInput
    _max?: CkpScoreMaxOrderByAggregateInput
    _min?: CkpScoreMinOrderByAggregateInput
    _sum?: CkpScoreSumOrderByAggregateInput
  }

  export type CkpScoreScalarWhereWithAggregatesInput = {
    AND?: CkpScoreScalarWhereWithAggregatesInput | CkpScoreScalarWhereWithAggregatesInput[]
    OR?: CkpScoreScalarWhereWithAggregatesInput[]
    NOT?: CkpScoreScalarWhereWithAggregatesInput | CkpScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CkpScore"> | string
    userId?: StringWithAggregatesFilter<"CkpScore"> | string
    periodId?: StringWithAggregatesFilter<"CkpScore"> | string
    score?: FloatWithAggregatesFilter<"CkpScore"> | number
    keterangan?: StringNullableWithAggregatesFilter<"CkpScore"> | string | null
    inputBy?: StringWithAggregatesFilter<"CkpScore"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CkpScore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CkpScore"> | Date | string
  }

  export type FinalEvaluationWhereInput = {
    AND?: FinalEvaluationWhereInput | FinalEvaluationWhereInput[]
    OR?: FinalEvaluationWhereInput[]
    NOT?: FinalEvaluationWhereInput | FinalEvaluationWhereInput[]
    id?: StringFilter<"FinalEvaluation"> | string
    userId?: StringFilter<"FinalEvaluation"> | string
    periodId?: StringFilter<"FinalEvaluation"> | string
    berakhlakScore?: FloatFilter<"FinalEvaluation"> | number
    presensiScore?: FloatFilter<"FinalEvaluation"> | number
    ckpScore?: FloatFilter<"FinalEvaluation"> | number
    finalScore?: FloatFilter<"FinalEvaluation"> | number
    totalEvaluators?: IntFilter<"FinalEvaluation"> | number
    ranking?: IntNullableFilter<"FinalEvaluation"> | number | null
    isBestEmployee?: BoolFilter<"FinalEvaluation"> | boolean
    createdAt?: DateTimeFilter<"FinalEvaluation"> | Date | string
    updatedAt?: DateTimeFilter<"FinalEvaluation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    period?: XOR<PeriodScalarRelationFilter, PeriodWhereInput>
  }

  export type FinalEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    berakhlakScore?: SortOrder
    presensiScore?: SortOrder
    ckpScore?: SortOrder
    finalScore?: SortOrder
    totalEvaluators?: SortOrder
    ranking?: SortOrderInput | SortOrder
    isBestEmployee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    period?: PeriodOrderByWithRelationInput
  }

  export type FinalEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_periodId?: FinalEvaluationUserIdPeriodIdCompoundUniqueInput
    AND?: FinalEvaluationWhereInput | FinalEvaluationWhereInput[]
    OR?: FinalEvaluationWhereInput[]
    NOT?: FinalEvaluationWhereInput | FinalEvaluationWhereInput[]
    userId?: StringFilter<"FinalEvaluation"> | string
    periodId?: StringFilter<"FinalEvaluation"> | string
    berakhlakScore?: FloatFilter<"FinalEvaluation"> | number
    presensiScore?: FloatFilter<"FinalEvaluation"> | number
    ckpScore?: FloatFilter<"FinalEvaluation"> | number
    finalScore?: FloatFilter<"FinalEvaluation"> | number
    totalEvaluators?: IntFilter<"FinalEvaluation"> | number
    ranking?: IntNullableFilter<"FinalEvaluation"> | number | null
    isBestEmployee?: BoolFilter<"FinalEvaluation"> | boolean
    createdAt?: DateTimeFilter<"FinalEvaluation"> | Date | string
    updatedAt?: DateTimeFilter<"FinalEvaluation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    period?: XOR<PeriodScalarRelationFilter, PeriodWhereInput>
  }, "id" | "userId_periodId">

  export type FinalEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    berakhlakScore?: SortOrder
    presensiScore?: SortOrder
    ckpScore?: SortOrder
    finalScore?: SortOrder
    totalEvaluators?: SortOrder
    ranking?: SortOrderInput | SortOrder
    isBestEmployee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FinalEvaluationCountOrderByAggregateInput
    _avg?: FinalEvaluationAvgOrderByAggregateInput
    _max?: FinalEvaluationMaxOrderByAggregateInput
    _min?: FinalEvaluationMinOrderByAggregateInput
    _sum?: FinalEvaluationSumOrderByAggregateInput
  }

  export type FinalEvaluationScalarWhereWithAggregatesInput = {
    AND?: FinalEvaluationScalarWhereWithAggregatesInput | FinalEvaluationScalarWhereWithAggregatesInput[]
    OR?: FinalEvaluationScalarWhereWithAggregatesInput[]
    NOT?: FinalEvaluationScalarWhereWithAggregatesInput | FinalEvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinalEvaluation"> | string
    userId?: StringWithAggregatesFilter<"FinalEvaluation"> | string
    periodId?: StringWithAggregatesFilter<"FinalEvaluation"> | string
    berakhlakScore?: FloatWithAggregatesFilter<"FinalEvaluation"> | number
    presensiScore?: FloatWithAggregatesFilter<"FinalEvaluation"> | number
    ckpScore?: FloatWithAggregatesFilter<"FinalEvaluation"> | number
    finalScore?: FloatWithAggregatesFilter<"FinalEvaluation"> | number
    totalEvaluators?: IntWithAggregatesFilter<"FinalEvaluation"> | number
    ranking?: IntNullableWithAggregatesFilter<"FinalEvaluation"> | number | null
    isBestEmployee?: BoolWithAggregatesFilter<"FinalEvaluation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FinalEvaluation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FinalEvaluation"> | Date | string
  }

  export type AspekPenilaianWhereInput = {
    AND?: AspekPenilaianWhereInput | AspekPenilaianWhereInput[]
    OR?: AspekPenilaianWhereInput[]
    NOT?: AspekPenilaianWhereInput | AspekPenilaianWhereInput[]
    id?: StringFilter<"AspekPenilaian"> | string
    namaAspek?: StringFilter<"AspekPenilaian"> | string
    deskripsi?: StringNullableFilter<"AspekPenilaian"> | string | null
    kategori?: StringNullableFilter<"AspekPenilaian"> | string | null
    bobot?: FloatFilter<"AspekPenilaian"> | number
    createdAt?: DateTimeFilter<"AspekPenilaian"> | Date | string
  }

  export type AspekPenilaianOrderByWithRelationInput = {
    id?: SortOrder
    namaAspek?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    kategori?: SortOrderInput | SortOrder
    bobot?: SortOrder
    createdAt?: SortOrder
  }

  export type AspekPenilaianWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AspekPenilaianWhereInput | AspekPenilaianWhereInput[]
    OR?: AspekPenilaianWhereInput[]
    NOT?: AspekPenilaianWhereInput | AspekPenilaianWhereInput[]
    namaAspek?: StringFilter<"AspekPenilaian"> | string
    deskripsi?: StringNullableFilter<"AspekPenilaian"> | string | null
    kategori?: StringNullableFilter<"AspekPenilaian"> | string | null
    bobot?: FloatFilter<"AspekPenilaian"> | number
    createdAt?: DateTimeFilter<"AspekPenilaian"> | Date | string
  }, "id">

  export type AspekPenilaianOrderByWithAggregationInput = {
    id?: SortOrder
    namaAspek?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    kategori?: SortOrderInput | SortOrder
    bobot?: SortOrder
    createdAt?: SortOrder
    _count?: AspekPenilaianCountOrderByAggregateInput
    _avg?: AspekPenilaianAvgOrderByAggregateInput
    _max?: AspekPenilaianMaxOrderByAggregateInput
    _min?: AspekPenilaianMinOrderByAggregateInput
    _sum?: AspekPenilaianSumOrderByAggregateInput
  }

  export type AspekPenilaianScalarWhereWithAggregatesInput = {
    AND?: AspekPenilaianScalarWhereWithAggregatesInput | AspekPenilaianScalarWhereWithAggregatesInput[]
    OR?: AspekPenilaianScalarWhereWithAggregatesInput[]
    NOT?: AspekPenilaianScalarWhereWithAggregatesInput | AspekPenilaianScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AspekPenilaian"> | string
    namaAspek?: StringWithAggregatesFilter<"AspekPenilaian"> | string
    deskripsi?: StringNullableWithAggregatesFilter<"AspekPenilaian"> | string | null
    kategori?: StringNullableWithAggregatesFilter<"AspekPenilaian"> | string | null
    bobot?: FloatWithAggregatesFilter<"AspekPenilaian"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AspekPenilaian"> | Date | string
  }

  export type RentangNilaiWhereInput = {
    AND?: RentangNilaiWhereInput | RentangNilaiWhereInput[]
    OR?: RentangNilaiWhereInput[]
    NOT?: RentangNilaiWhereInput | RentangNilaiWhereInput[]
    id?: StringFilter<"RentangNilai"> | string
    kategori?: StringFilter<"RentangNilai"> | string
    nilaiMin?: IntFilter<"RentangNilai"> | number
    nilaiMax?: IntFilter<"RentangNilai"> | number
    deskripsi?: StringNullableFilter<"RentangNilai"> | string | null
    createdAt?: DateTimeFilter<"RentangNilai"> | Date | string
  }

  export type RentangNilaiOrderByWithRelationInput = {
    id?: SortOrder
    kategori?: SortOrder
    nilaiMin?: SortOrder
    nilaiMax?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type RentangNilaiWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RentangNilaiWhereInput | RentangNilaiWhereInput[]
    OR?: RentangNilaiWhereInput[]
    NOT?: RentangNilaiWhereInput | RentangNilaiWhereInput[]
    kategori?: StringFilter<"RentangNilai"> | string
    nilaiMin?: IntFilter<"RentangNilai"> | number
    nilaiMax?: IntFilter<"RentangNilai"> | number
    deskripsi?: StringNullableFilter<"RentangNilai"> | string | null
    createdAt?: DateTimeFilter<"RentangNilai"> | Date | string
  }, "id">

  export type RentangNilaiOrderByWithAggregationInput = {
    id?: SortOrder
    kategori?: SortOrder
    nilaiMin?: SortOrder
    nilaiMax?: SortOrder
    deskripsi?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RentangNilaiCountOrderByAggregateInput
    _avg?: RentangNilaiAvgOrderByAggregateInput
    _max?: RentangNilaiMaxOrderByAggregateInput
    _min?: RentangNilaiMinOrderByAggregateInput
    _sum?: RentangNilaiSumOrderByAggregateInput
  }

  export type RentangNilaiScalarWhereWithAggregatesInput = {
    AND?: RentangNilaiScalarWhereWithAggregatesInput | RentangNilaiScalarWhereWithAggregatesInput[]
    OR?: RentangNilaiScalarWhereWithAggregatesInput[]
    NOT?: RentangNilaiScalarWhereWithAggregatesInput | RentangNilaiScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RentangNilai"> | string
    kategori?: StringWithAggregatesFilter<"RentangNilai"> | string
    nilaiMin?: IntWithAggregatesFilter<"RentangNilai"> | number
    nilaiMax?: IntWithAggregatesFilter<"RentangNilai"> | number
    deskripsi?: StringNullableWithAggregatesFilter<"RentangNilai"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RentangNilai"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationsGiven?: EvaluationCreateNestedManyWithoutEvaluatorInput
    evaluationsReceived?: EvaluationCreateNestedManyWithoutTargetInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    ckpScores?: CkpScoreCreateNestedManyWithoutUserInput
    finalEvaluations?: FinalEvaluationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationsGiven?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    evaluationsReceived?: EvaluationUncheckedCreateNestedManyWithoutTargetInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    ckpScores?: CkpScoreUncheckedCreateNestedManyWithoutUserInput
    finalEvaluations?: FinalEvaluationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationsGiven?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    evaluationsReceived?: EvaluationUpdateManyWithoutTargetNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    ckpScores?: CkpScoreUpdateManyWithoutUserNestedInput
    finalEvaluations?: FinalEvaluationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationsGiven?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    evaluationsReceived?: EvaluationUncheckedUpdateManyWithoutTargetNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    ckpScores?: CkpScoreUncheckedUpdateManyWithoutUserNestedInput
    finalEvaluations?: FinalEvaluationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodCreateInput = {
    id?: string
    tahun: number
    bulan: number
    namaPeriode: string
    noPeriode?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutPeriodInput
    attendances?: AttendanceCreateNestedManyWithoutPeriodInput
    ckpScores?: CkpScoreCreateNestedManyWithoutPeriodInput
    finalEvaluations?: FinalEvaluationCreateNestedManyWithoutPeriodInput
  }

  export type PeriodUncheckedCreateInput = {
    id?: string
    tahun: number
    bulan: number
    namaPeriode: string
    noPeriode?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPeriodInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutPeriodInput
    ckpScores?: CkpScoreUncheckedCreateNestedManyWithoutPeriodInput
    finalEvaluations?: FinalEvaluationUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type PeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    bulan?: IntFieldUpdateOperationsInput | number
    namaPeriode?: StringFieldUpdateOperationsInput | string
    noPeriode?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutPeriodNestedInput
    attendances?: AttendanceUpdateManyWithoutPeriodNestedInput
    ckpScores?: CkpScoreUpdateManyWithoutPeriodNestedInput
    finalEvaluations?: FinalEvaluationUpdateManyWithoutPeriodNestedInput
  }

  export type PeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    bulan?: IntFieldUpdateOperationsInput | number
    namaPeriode?: StringFieldUpdateOperationsInput | string
    noPeriode?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutPeriodNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutPeriodNestedInput
    ckpScores?: CkpScoreUncheckedUpdateManyWithoutPeriodNestedInput
    finalEvaluations?: FinalEvaluationUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type PeriodCreateManyInput = {
    id?: string
    tahun: number
    bulan: number
    namaPeriode: string
    noPeriode?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    bulan?: IntFieldUpdateOperationsInput | number
    namaPeriode?: StringFieldUpdateOperationsInput | string
    noPeriode?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    bulan?: IntFieldUpdateOperationsInput | number
    namaPeriode?: StringFieldUpdateOperationsInput | string
    noPeriode?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationParameterCreateInput = {
    id?: string
    namaParameter: string
    deskripsi?: string | null
    kategori?: string
    urutan: number
    createdAt?: Date | string
    evaluationScores?: EvaluationScoreCreateNestedManyWithoutParameterInput
  }

  export type EvaluationParameterUncheckedCreateInput = {
    id?: string
    namaParameter: string
    deskripsi?: string | null
    kategori?: string
    urutan: number
    createdAt?: Date | string
    evaluationScores?: EvaluationScoreUncheckedCreateNestedManyWithoutParameterInput
  }

  export type EvaluationParameterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    namaParameter?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: StringFieldUpdateOperationsInput | string
    urutan?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationScores?: EvaluationScoreUpdateManyWithoutParameterNestedInput
  }

  export type EvaluationParameterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    namaParameter?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: StringFieldUpdateOperationsInput | string
    urutan?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationScores?: EvaluationScoreUncheckedUpdateManyWithoutParameterNestedInput
  }

  export type EvaluationParameterCreateManyInput = {
    id?: string
    namaParameter: string
    deskripsi?: string | null
    kategori?: string
    urutan: number
    createdAt?: Date | string
  }

  export type EvaluationParameterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    namaParameter?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: StringFieldUpdateOperationsInput | string
    urutan?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationParameterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    namaParameter?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: StringFieldUpdateOperationsInput | string
    urutan?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateInput = {
    id?: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluator: UserCreateNestedOneWithoutEvaluationsGivenInput
    target: UserCreateNestedOneWithoutEvaluationsReceivedInput
    period: PeriodCreateNestedOneWithoutEvaluationsInput
    scores?: EvaluationScoreCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateInput = {
    id?: string
    evaluatorId: string
    periodId: string
    targetUserId: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    scores?: EvaluationScoreUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluator?: UserUpdateOneRequiredWithoutEvaluationsGivenNestedInput
    target?: UserUpdateOneRequiredWithoutEvaluationsReceivedNestedInput
    period?: PeriodUpdateOneRequiredWithoutEvaluationsNestedInput
    scores?: EvaluationScoreUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scores?: EvaluationScoreUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationCreateManyInput = {
    id?: string
    evaluatorId: string
    periodId: string
    targetUserId: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationScoreCreateInput = {
    id?: string
    score: number
    createdAt?: Date | string
    evaluation: EvaluationCreateNestedOneWithoutScoresInput
    parameter: EvaluationParameterCreateNestedOneWithoutEvaluationScoresInput
  }

  export type EvaluationScoreUncheckedCreateInput = {
    id?: string
    evaluationId: string
    parameterId: string
    score: number
    createdAt?: Date | string
  }

  export type EvaluationScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluation?: EvaluationUpdateOneRequiredWithoutScoresNestedInput
    parameter?: EvaluationParameterUpdateOneRequiredWithoutEvaluationScoresNestedInput
  }

  export type EvaluationScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationScoreCreateManyInput = {
    id?: string
    evaluationId: string
    parameterId: string
    score: number
    createdAt?: Date | string
  }

  export type EvaluationScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    persentaseTotal?: number
    tidakKerja?: number
    pulangAwal?: number
    telat?: number
    absenApel?: number
    cuti?: number
    totalMinus?: number
    nilaiPresensi?: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendancesInput
    period: PeriodCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    userId: string
    periodId: string
    persentaseTotal?: number
    tidakKerja?: number
    pulangAwal?: number
    telat?: number
    absenApel?: number
    cuti?: number
    totalMinus?: number
    nilaiPresensi?: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    persentaseTotal?: FloatFieldUpdateOperationsInput | number
    tidakKerja?: FloatFieldUpdateOperationsInput | number
    pulangAwal?: FloatFieldUpdateOperationsInput | number
    telat?: FloatFieldUpdateOperationsInput | number
    absenApel?: FloatFieldUpdateOperationsInput | number
    cuti?: FloatFieldUpdateOperationsInput | number
    totalMinus?: FloatFieldUpdateOperationsInput | number
    nilaiPresensi?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendancesNestedInput
    period?: PeriodUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    persentaseTotal?: FloatFieldUpdateOperationsInput | number
    tidakKerja?: FloatFieldUpdateOperationsInput | number
    pulangAwal?: FloatFieldUpdateOperationsInput | number
    telat?: FloatFieldUpdateOperationsInput | number
    absenApel?: FloatFieldUpdateOperationsInput | number
    cuti?: FloatFieldUpdateOperationsInput | number
    totalMinus?: FloatFieldUpdateOperationsInput | number
    nilaiPresensi?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    userId: string
    periodId: string
    persentaseTotal?: number
    tidakKerja?: number
    pulangAwal?: number
    telat?: number
    absenApel?: number
    cuti?: number
    totalMinus?: number
    nilaiPresensi?: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    persentaseTotal?: FloatFieldUpdateOperationsInput | number
    tidakKerja?: FloatFieldUpdateOperationsInput | number
    pulangAwal?: FloatFieldUpdateOperationsInput | number
    telat?: FloatFieldUpdateOperationsInput | number
    absenApel?: FloatFieldUpdateOperationsInput | number
    cuti?: FloatFieldUpdateOperationsInput | number
    totalMinus?: FloatFieldUpdateOperationsInput | number
    nilaiPresensi?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    persentaseTotal?: FloatFieldUpdateOperationsInput | number
    tidakKerja?: FloatFieldUpdateOperationsInput | number
    pulangAwal?: FloatFieldUpdateOperationsInput | number
    telat?: FloatFieldUpdateOperationsInput | number
    absenApel?: FloatFieldUpdateOperationsInput | number
    cuti?: FloatFieldUpdateOperationsInput | number
    totalMinus?: FloatFieldUpdateOperationsInput | number
    nilaiPresensi?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CkpScoreCreateInput = {
    id?: string
    score: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCkpScoresInput
    period: PeriodCreateNestedOneWithoutCkpScoresInput
  }

  export type CkpScoreUncheckedCreateInput = {
    id?: string
    userId: string
    periodId: string
    score: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CkpScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCkpScoresNestedInput
    period?: PeriodUpdateOneRequiredWithoutCkpScoresNestedInput
  }

  export type CkpScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CkpScoreCreateManyInput = {
    id?: string
    userId: string
    periodId: string
    score: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CkpScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CkpScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinalEvaluationCreateInput = {
    id?: string
    berakhlakScore?: number
    presensiScore?: number
    ckpScore?: number
    finalScore?: number
    totalEvaluators?: number
    ranking?: number | null
    isBestEmployee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFinalEvaluationsInput
    period: PeriodCreateNestedOneWithoutFinalEvaluationsInput
  }

  export type FinalEvaluationUncheckedCreateInput = {
    id?: string
    userId: string
    periodId: string
    berakhlakScore?: number
    presensiScore?: number
    ckpScore?: number
    finalScore?: number
    totalEvaluators?: number
    ranking?: number | null
    isBestEmployee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinalEvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    berakhlakScore?: FloatFieldUpdateOperationsInput | number
    presensiScore?: FloatFieldUpdateOperationsInput | number
    ckpScore?: FloatFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    totalEvaluators?: IntFieldUpdateOperationsInput | number
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    isBestEmployee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFinalEvaluationsNestedInput
    period?: PeriodUpdateOneRequiredWithoutFinalEvaluationsNestedInput
  }

  export type FinalEvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    berakhlakScore?: FloatFieldUpdateOperationsInput | number
    presensiScore?: FloatFieldUpdateOperationsInput | number
    ckpScore?: FloatFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    totalEvaluators?: IntFieldUpdateOperationsInput | number
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    isBestEmployee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinalEvaluationCreateManyInput = {
    id?: string
    userId: string
    periodId: string
    berakhlakScore?: number
    presensiScore?: number
    ckpScore?: number
    finalScore?: number
    totalEvaluators?: number
    ranking?: number | null
    isBestEmployee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinalEvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    berakhlakScore?: FloatFieldUpdateOperationsInput | number
    presensiScore?: FloatFieldUpdateOperationsInput | number
    ckpScore?: FloatFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    totalEvaluators?: IntFieldUpdateOperationsInput | number
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    isBestEmployee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinalEvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    berakhlakScore?: FloatFieldUpdateOperationsInput | number
    presensiScore?: FloatFieldUpdateOperationsInput | number
    ckpScore?: FloatFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    totalEvaluators?: IntFieldUpdateOperationsInput | number
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    isBestEmployee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AspekPenilaianCreateInput = {
    id?: string
    namaAspek: string
    deskripsi?: string | null
    kategori?: string | null
    bobot?: number
    createdAt?: Date | string
  }

  export type AspekPenilaianUncheckedCreateInput = {
    id?: string
    namaAspek: string
    deskripsi?: string | null
    kategori?: string | null
    bobot?: number
    createdAt?: Date | string
  }

  export type AspekPenilaianUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    namaAspek?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableStringFieldUpdateOperationsInput | string | null
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AspekPenilaianUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    namaAspek?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableStringFieldUpdateOperationsInput | string | null
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AspekPenilaianCreateManyInput = {
    id?: string
    namaAspek: string
    deskripsi?: string | null
    kategori?: string | null
    bobot?: number
    createdAt?: Date | string
  }

  export type AspekPenilaianUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    namaAspek?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableStringFieldUpdateOperationsInput | string | null
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AspekPenilaianUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    namaAspek?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: NullableStringFieldUpdateOperationsInput | string | null
    bobot?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentangNilaiCreateInput = {
    id?: string
    kategori: string
    nilaiMin: number
    nilaiMax: number
    deskripsi?: string | null
    createdAt?: Date | string
  }

  export type RentangNilaiUncheckedCreateInput = {
    id?: string
    kategori: string
    nilaiMin: number
    nilaiMax: number
    deskripsi?: string | null
    createdAt?: Date | string
  }

  export type RentangNilaiUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kategori?: StringFieldUpdateOperationsInput | string
    nilaiMin?: IntFieldUpdateOperationsInput | number
    nilaiMax?: IntFieldUpdateOperationsInput | number
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentangNilaiUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kategori?: StringFieldUpdateOperationsInput | string
    nilaiMin?: IntFieldUpdateOperationsInput | number
    nilaiMax?: IntFieldUpdateOperationsInput | number
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentangNilaiCreateManyInput = {
    id?: string
    kategori: string
    nilaiMin: number
    nilaiMax: number
    deskripsi?: string | null
    createdAt?: Date | string
  }

  export type RentangNilaiUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kategori?: StringFieldUpdateOperationsInput | string
    nilaiMin?: IntFieldUpdateOperationsInput | number
    nilaiMax?: IntFieldUpdateOperationsInput | number
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentangNilaiUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kategori?: StringFieldUpdateOperationsInput | string
    nilaiMin?: IntFieldUpdateOperationsInput | number
    nilaiMax?: IntFieldUpdateOperationsInput | number
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EvaluationListRelationFilter = {
    every?: EvaluationWhereInput
    some?: EvaluationWhereInput
    none?: EvaluationWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type CkpScoreListRelationFilter = {
    every?: CkpScoreWhereInput
    some?: CkpScoreWhereInput
    none?: CkpScoreWhereInput
  }

  export type FinalEvaluationListRelationFilter = {
    every?: FinalEvaluationWhereInput
    some?: FinalEvaluationWhereInput
    none?: FinalEvaluationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CkpScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinalEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    nip?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    jenisKelamin?: SortOrder
    tanggalLahir?: SortOrder
    alamat?: SortOrder
    mobilePhone?: SortOrder
    pendidikanTerakhir?: SortOrder
    jabatan?: SortOrder
    golongan?: SortOrder
    status?: SortOrder
    instansi?: SortOrder
    kantor?: SortOrder
    username?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    nip?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    jenisKelamin?: SortOrder
    tanggalLahir?: SortOrder
    alamat?: SortOrder
    mobilePhone?: SortOrder
    pendidikanTerakhir?: SortOrder
    jabatan?: SortOrder
    golongan?: SortOrder
    status?: SortOrder
    instansi?: SortOrder
    kantor?: SortOrder
    username?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    nip?: SortOrder
    nama?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    jenisKelamin?: SortOrder
    tanggalLahir?: SortOrder
    alamat?: SortOrder
    mobilePhone?: SortOrder
    pendidikanTerakhir?: SortOrder
    jabatan?: SortOrder
    golongan?: SortOrder
    status?: SortOrder
    instansi?: SortOrder
    kantor?: SortOrder
    username?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PeriodTahunBulanCompoundUniqueInput = {
    tahun: number
    bulan: number
  }

  export type PeriodCountOrderByAggregateInput = {
    id?: SortOrder
    tahun?: SortOrder
    bulan?: SortOrder
    namaPeriode?: SortOrder
    noPeriode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PeriodAvgOrderByAggregateInput = {
    tahun?: SortOrder
    bulan?: SortOrder
    noPeriode?: SortOrder
  }

  export type PeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    tahun?: SortOrder
    bulan?: SortOrder
    namaPeriode?: SortOrder
    noPeriode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PeriodMinOrderByAggregateInput = {
    id?: SortOrder
    tahun?: SortOrder
    bulan?: SortOrder
    namaPeriode?: SortOrder
    noPeriode?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PeriodSumOrderByAggregateInput = {
    tahun?: SortOrder
    bulan?: SortOrder
    noPeriode?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EvaluationScoreListRelationFilter = {
    every?: EvaluationScoreWhereInput
    some?: EvaluationScoreWhereInput
    none?: EvaluationScoreWhereInput
  }

  export type EvaluationScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationParameterCountOrderByAggregateInput = {
    id?: SortOrder
    namaParameter?: SortOrder
    deskripsi?: SortOrder
    kategori?: SortOrder
    urutan?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationParameterAvgOrderByAggregateInput = {
    urutan?: SortOrder
  }

  export type EvaluationParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    namaParameter?: SortOrder
    deskripsi?: SortOrder
    kategori?: SortOrder
    urutan?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationParameterMinOrderByAggregateInput = {
    id?: SortOrder
    namaParameter?: SortOrder
    deskripsi?: SortOrder
    kategori?: SortOrder
    urutan?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationParameterSumOrderByAggregateInput = {
    urutan?: SortOrder
  }

  export type EnumEvaluationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EvaluationStatus | EnumEvaluationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EvaluationStatus[] | ListEnumEvaluationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvaluationStatus[] | ListEnumEvaluationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEvaluationStatusFilter<$PrismaModel> | $Enums.EvaluationStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PeriodScalarRelationFilter = {
    is?: PeriodWhereInput
    isNot?: PeriodWhereInput
  }

  export type EvaluationEvaluatorIdPeriodIdTargetUserIdCompoundUniqueInput = {
    evaluatorId: string
    periodId: string
    targetUserId: string
  }

  export type EvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    evaluatorId?: SortOrder
    periodId?: SortOrder
    targetUserId?: SortOrder
    ranking?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationAvgOrderByAggregateInput = {
    ranking?: SortOrder
  }

  export type EvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    evaluatorId?: SortOrder
    periodId?: SortOrder
    targetUserId?: SortOrder
    ranking?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    evaluatorId?: SortOrder
    periodId?: SortOrder
    targetUserId?: SortOrder
    ranking?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationSumOrderByAggregateInput = {
    ranking?: SortOrder
  }

  export type EnumEvaluationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvaluationStatus | EnumEvaluationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EvaluationStatus[] | ListEnumEvaluationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvaluationStatus[] | ListEnumEvaluationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEvaluationStatusWithAggregatesFilter<$PrismaModel> | $Enums.EvaluationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvaluationStatusFilter<$PrismaModel>
    _max?: NestedEnumEvaluationStatusFilter<$PrismaModel>
  }

  export type EvaluationScalarRelationFilter = {
    is?: EvaluationWhereInput
    isNot?: EvaluationWhereInput
  }

  export type EvaluationParameterScalarRelationFilter = {
    is?: EvaluationParameterWhereInput
    isNot?: EvaluationParameterWhereInput
  }

  export type EvaluationScoreEvaluationIdParameterIdCompoundUniqueInput = {
    evaluationId: string
    parameterId: string
  }

  export type EvaluationScoreCountOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
    parameterId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationScoreAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EvaluationScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
    parameterId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationScoreMinOrderByAggregateInput = {
    id?: SortOrder
    evaluationId?: SortOrder
    parameterId?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
  }

  export type EvaluationScoreSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AttendanceUserIdPeriodIdCompoundUniqueInput = {
    userId: string
    periodId: string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    persentaseTotal?: SortOrder
    tidakKerja?: SortOrder
    pulangAwal?: SortOrder
    telat?: SortOrder
    absenApel?: SortOrder
    cuti?: SortOrder
    totalMinus?: SortOrder
    nilaiPresensi?: SortOrder
    keterangan?: SortOrder
    inputBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceAvgOrderByAggregateInput = {
    persentaseTotal?: SortOrder
    tidakKerja?: SortOrder
    pulangAwal?: SortOrder
    telat?: SortOrder
    absenApel?: SortOrder
    cuti?: SortOrder
    totalMinus?: SortOrder
    nilaiPresensi?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    persentaseTotal?: SortOrder
    tidakKerja?: SortOrder
    pulangAwal?: SortOrder
    telat?: SortOrder
    absenApel?: SortOrder
    cuti?: SortOrder
    totalMinus?: SortOrder
    nilaiPresensi?: SortOrder
    keterangan?: SortOrder
    inputBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    persentaseTotal?: SortOrder
    tidakKerja?: SortOrder
    pulangAwal?: SortOrder
    telat?: SortOrder
    absenApel?: SortOrder
    cuti?: SortOrder
    totalMinus?: SortOrder
    nilaiPresensi?: SortOrder
    keterangan?: SortOrder
    inputBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceSumOrderByAggregateInput = {
    persentaseTotal?: SortOrder
    tidakKerja?: SortOrder
    pulangAwal?: SortOrder
    telat?: SortOrder
    absenApel?: SortOrder
    cuti?: SortOrder
    totalMinus?: SortOrder
    nilaiPresensi?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CkpScoreUserIdPeriodIdCompoundUniqueInput = {
    userId: string
    periodId: string
  }

  export type CkpScoreCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    score?: SortOrder
    keterangan?: SortOrder
    inputBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CkpScoreAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type CkpScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    score?: SortOrder
    keterangan?: SortOrder
    inputBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CkpScoreMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    score?: SortOrder
    keterangan?: SortOrder
    inputBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CkpScoreSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FinalEvaluationUserIdPeriodIdCompoundUniqueInput = {
    userId: string
    periodId: string
  }

  export type FinalEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    berakhlakScore?: SortOrder
    presensiScore?: SortOrder
    ckpScore?: SortOrder
    finalScore?: SortOrder
    totalEvaluators?: SortOrder
    ranking?: SortOrder
    isBestEmployee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinalEvaluationAvgOrderByAggregateInput = {
    berakhlakScore?: SortOrder
    presensiScore?: SortOrder
    ckpScore?: SortOrder
    finalScore?: SortOrder
    totalEvaluators?: SortOrder
    ranking?: SortOrder
  }

  export type FinalEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    berakhlakScore?: SortOrder
    presensiScore?: SortOrder
    ckpScore?: SortOrder
    finalScore?: SortOrder
    totalEvaluators?: SortOrder
    ranking?: SortOrder
    isBestEmployee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinalEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    periodId?: SortOrder
    berakhlakScore?: SortOrder
    presensiScore?: SortOrder
    ckpScore?: SortOrder
    finalScore?: SortOrder
    totalEvaluators?: SortOrder
    ranking?: SortOrder
    isBestEmployee?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinalEvaluationSumOrderByAggregateInput = {
    berakhlakScore?: SortOrder
    presensiScore?: SortOrder
    ckpScore?: SortOrder
    finalScore?: SortOrder
    totalEvaluators?: SortOrder
    ranking?: SortOrder
  }

  export type AspekPenilaianCountOrderByAggregateInput = {
    id?: SortOrder
    namaAspek?: SortOrder
    deskripsi?: SortOrder
    kategori?: SortOrder
    bobot?: SortOrder
    createdAt?: SortOrder
  }

  export type AspekPenilaianAvgOrderByAggregateInput = {
    bobot?: SortOrder
  }

  export type AspekPenilaianMaxOrderByAggregateInput = {
    id?: SortOrder
    namaAspek?: SortOrder
    deskripsi?: SortOrder
    kategori?: SortOrder
    bobot?: SortOrder
    createdAt?: SortOrder
  }

  export type AspekPenilaianMinOrderByAggregateInput = {
    id?: SortOrder
    namaAspek?: SortOrder
    deskripsi?: SortOrder
    kategori?: SortOrder
    bobot?: SortOrder
    createdAt?: SortOrder
  }

  export type AspekPenilaianSumOrderByAggregateInput = {
    bobot?: SortOrder
  }

  export type RentangNilaiCountOrderByAggregateInput = {
    id?: SortOrder
    kategori?: SortOrder
    nilaiMin?: SortOrder
    nilaiMax?: SortOrder
    deskripsi?: SortOrder
    createdAt?: SortOrder
  }

  export type RentangNilaiAvgOrderByAggregateInput = {
    nilaiMin?: SortOrder
    nilaiMax?: SortOrder
  }

  export type RentangNilaiMaxOrderByAggregateInput = {
    id?: SortOrder
    kategori?: SortOrder
    nilaiMin?: SortOrder
    nilaiMax?: SortOrder
    deskripsi?: SortOrder
    createdAt?: SortOrder
  }

  export type RentangNilaiMinOrderByAggregateInput = {
    id?: SortOrder
    kategori?: SortOrder
    nilaiMin?: SortOrder
    nilaiMax?: SortOrder
    deskripsi?: SortOrder
    createdAt?: SortOrder
  }

  export type RentangNilaiSumOrderByAggregateInput = {
    nilaiMin?: SortOrder
    nilaiMax?: SortOrder
  }

  export type EvaluationCreateNestedManyWithoutEvaluatorInput = {
    create?: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput> | EvaluationCreateWithoutEvaluatorInput[] | EvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEvaluatorInput | EvaluationCreateOrConnectWithoutEvaluatorInput[]
    createMany?: EvaluationCreateManyEvaluatorInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutTargetInput = {
    create?: XOR<EvaluationCreateWithoutTargetInput, EvaluationUncheckedCreateWithoutTargetInput> | EvaluationCreateWithoutTargetInput[] | EvaluationUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutTargetInput | EvaluationCreateOrConnectWithoutTargetInput[]
    createMany?: EvaluationCreateManyTargetInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type CkpScoreCreateNestedManyWithoutUserInput = {
    create?: XOR<CkpScoreCreateWithoutUserInput, CkpScoreUncheckedCreateWithoutUserInput> | CkpScoreCreateWithoutUserInput[] | CkpScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CkpScoreCreateOrConnectWithoutUserInput | CkpScoreCreateOrConnectWithoutUserInput[]
    createMany?: CkpScoreCreateManyUserInputEnvelope
    connect?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
  }

  export type FinalEvaluationCreateNestedManyWithoutUserInput = {
    create?: XOR<FinalEvaluationCreateWithoutUserInput, FinalEvaluationUncheckedCreateWithoutUserInput> | FinalEvaluationCreateWithoutUserInput[] | FinalEvaluationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinalEvaluationCreateOrConnectWithoutUserInput | FinalEvaluationCreateOrConnectWithoutUserInput[]
    createMany?: FinalEvaluationCreateManyUserInputEnvelope
    connect?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput = {
    create?: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput> | EvaluationCreateWithoutEvaluatorInput[] | EvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEvaluatorInput | EvaluationCreateOrConnectWithoutEvaluatorInput[]
    createMany?: EvaluationCreateManyEvaluatorInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutTargetInput = {
    create?: XOR<EvaluationCreateWithoutTargetInput, EvaluationUncheckedCreateWithoutTargetInput> | EvaluationCreateWithoutTargetInput[] | EvaluationUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutTargetInput | EvaluationCreateOrConnectWithoutTargetInput[]
    createMany?: EvaluationCreateManyTargetInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type CkpScoreUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CkpScoreCreateWithoutUserInput, CkpScoreUncheckedCreateWithoutUserInput> | CkpScoreCreateWithoutUserInput[] | CkpScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CkpScoreCreateOrConnectWithoutUserInput | CkpScoreCreateOrConnectWithoutUserInput[]
    createMany?: CkpScoreCreateManyUserInputEnvelope
    connect?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
  }

  export type FinalEvaluationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FinalEvaluationCreateWithoutUserInput, FinalEvaluationUncheckedCreateWithoutUserInput> | FinalEvaluationCreateWithoutUserInput[] | FinalEvaluationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinalEvaluationCreateOrConnectWithoutUserInput | FinalEvaluationCreateOrConnectWithoutUserInput[]
    createMany?: FinalEvaluationCreateManyUserInputEnvelope
    connect?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EvaluationUpdateManyWithoutEvaluatorNestedInput = {
    create?: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput> | EvaluationCreateWithoutEvaluatorInput[] | EvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEvaluatorInput | EvaluationCreateOrConnectWithoutEvaluatorInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput | EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput[]
    createMany?: EvaluationCreateManyEvaluatorInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput | EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutEvaluatorInput | EvaluationUpdateManyWithWhereWithoutEvaluatorInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutTargetNestedInput = {
    create?: XOR<EvaluationCreateWithoutTargetInput, EvaluationUncheckedCreateWithoutTargetInput> | EvaluationCreateWithoutTargetInput[] | EvaluationUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutTargetInput | EvaluationCreateOrConnectWithoutTargetInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutTargetInput | EvaluationUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: EvaluationCreateManyTargetInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutTargetInput | EvaluationUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutTargetInput | EvaluationUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type CkpScoreUpdateManyWithoutUserNestedInput = {
    create?: XOR<CkpScoreCreateWithoutUserInput, CkpScoreUncheckedCreateWithoutUserInput> | CkpScoreCreateWithoutUserInput[] | CkpScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CkpScoreCreateOrConnectWithoutUserInput | CkpScoreCreateOrConnectWithoutUserInput[]
    upsert?: CkpScoreUpsertWithWhereUniqueWithoutUserInput | CkpScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CkpScoreCreateManyUserInputEnvelope
    set?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    disconnect?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    delete?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    connect?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    update?: CkpScoreUpdateWithWhereUniqueWithoutUserInput | CkpScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CkpScoreUpdateManyWithWhereWithoutUserInput | CkpScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CkpScoreScalarWhereInput | CkpScoreScalarWhereInput[]
  }

  export type FinalEvaluationUpdateManyWithoutUserNestedInput = {
    create?: XOR<FinalEvaluationCreateWithoutUserInput, FinalEvaluationUncheckedCreateWithoutUserInput> | FinalEvaluationCreateWithoutUserInput[] | FinalEvaluationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinalEvaluationCreateOrConnectWithoutUserInput | FinalEvaluationCreateOrConnectWithoutUserInput[]
    upsert?: FinalEvaluationUpsertWithWhereUniqueWithoutUserInput | FinalEvaluationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FinalEvaluationCreateManyUserInputEnvelope
    set?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    disconnect?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    delete?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    connect?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    update?: FinalEvaluationUpdateWithWhereUniqueWithoutUserInput | FinalEvaluationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FinalEvaluationUpdateManyWithWhereWithoutUserInput | FinalEvaluationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FinalEvaluationScalarWhereInput | FinalEvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput = {
    create?: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput> | EvaluationCreateWithoutEvaluatorInput[] | EvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutEvaluatorInput | EvaluationCreateOrConnectWithoutEvaluatorInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput | EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput[]
    createMany?: EvaluationCreateManyEvaluatorInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput | EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutEvaluatorInput | EvaluationUpdateManyWithWhereWithoutEvaluatorInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutTargetNestedInput = {
    create?: XOR<EvaluationCreateWithoutTargetInput, EvaluationUncheckedCreateWithoutTargetInput> | EvaluationCreateWithoutTargetInput[] | EvaluationUncheckedCreateWithoutTargetInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutTargetInput | EvaluationCreateOrConnectWithoutTargetInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutTargetInput | EvaluationUpsertWithWhereUniqueWithoutTargetInput[]
    createMany?: EvaluationCreateManyTargetInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutTargetInput | EvaluationUpdateWithWhereUniqueWithoutTargetInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutTargetInput | EvaluationUpdateManyWithWhereWithoutTargetInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput> | AttendanceCreateWithoutUserInput[] | AttendanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutUserInput | AttendanceCreateOrConnectWithoutUserInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutUserInput | AttendanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AttendanceCreateManyUserInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutUserInput | AttendanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutUserInput | AttendanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type CkpScoreUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CkpScoreCreateWithoutUserInput, CkpScoreUncheckedCreateWithoutUserInput> | CkpScoreCreateWithoutUserInput[] | CkpScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CkpScoreCreateOrConnectWithoutUserInput | CkpScoreCreateOrConnectWithoutUserInput[]
    upsert?: CkpScoreUpsertWithWhereUniqueWithoutUserInput | CkpScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CkpScoreCreateManyUserInputEnvelope
    set?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    disconnect?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    delete?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    connect?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    update?: CkpScoreUpdateWithWhereUniqueWithoutUserInput | CkpScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CkpScoreUpdateManyWithWhereWithoutUserInput | CkpScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CkpScoreScalarWhereInput | CkpScoreScalarWhereInput[]
  }

  export type FinalEvaluationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FinalEvaluationCreateWithoutUserInput, FinalEvaluationUncheckedCreateWithoutUserInput> | FinalEvaluationCreateWithoutUserInput[] | FinalEvaluationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FinalEvaluationCreateOrConnectWithoutUserInput | FinalEvaluationCreateOrConnectWithoutUserInput[]
    upsert?: FinalEvaluationUpsertWithWhereUniqueWithoutUserInput | FinalEvaluationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FinalEvaluationCreateManyUserInputEnvelope
    set?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    disconnect?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    delete?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    connect?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    update?: FinalEvaluationUpdateWithWhereUniqueWithoutUserInput | FinalEvaluationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FinalEvaluationUpdateManyWithWhereWithoutUserInput | FinalEvaluationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FinalEvaluationScalarWhereInput | FinalEvaluationScalarWhereInput[]
  }

  export type EvaluationCreateNestedManyWithoutPeriodInput = {
    create?: XOR<EvaluationCreateWithoutPeriodInput, EvaluationUncheckedCreateWithoutPeriodInput> | EvaluationCreateWithoutPeriodInput[] | EvaluationUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutPeriodInput | EvaluationCreateOrConnectWithoutPeriodInput[]
    createMany?: EvaluationCreateManyPeriodInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutPeriodInput = {
    create?: XOR<AttendanceCreateWithoutPeriodInput, AttendanceUncheckedCreateWithoutPeriodInput> | AttendanceCreateWithoutPeriodInput[] | AttendanceUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutPeriodInput | AttendanceCreateOrConnectWithoutPeriodInput[]
    createMany?: AttendanceCreateManyPeriodInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type CkpScoreCreateNestedManyWithoutPeriodInput = {
    create?: XOR<CkpScoreCreateWithoutPeriodInput, CkpScoreUncheckedCreateWithoutPeriodInput> | CkpScoreCreateWithoutPeriodInput[] | CkpScoreUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: CkpScoreCreateOrConnectWithoutPeriodInput | CkpScoreCreateOrConnectWithoutPeriodInput[]
    createMany?: CkpScoreCreateManyPeriodInputEnvelope
    connect?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
  }

  export type FinalEvaluationCreateNestedManyWithoutPeriodInput = {
    create?: XOR<FinalEvaluationCreateWithoutPeriodInput, FinalEvaluationUncheckedCreateWithoutPeriodInput> | FinalEvaluationCreateWithoutPeriodInput[] | FinalEvaluationUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: FinalEvaluationCreateOrConnectWithoutPeriodInput | FinalEvaluationCreateOrConnectWithoutPeriodInput[]
    createMany?: FinalEvaluationCreateManyPeriodInputEnvelope
    connect?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutPeriodInput = {
    create?: XOR<EvaluationCreateWithoutPeriodInput, EvaluationUncheckedCreateWithoutPeriodInput> | EvaluationCreateWithoutPeriodInput[] | EvaluationUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutPeriodInput | EvaluationCreateOrConnectWithoutPeriodInput[]
    createMany?: EvaluationCreateManyPeriodInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutPeriodInput = {
    create?: XOR<AttendanceCreateWithoutPeriodInput, AttendanceUncheckedCreateWithoutPeriodInput> | AttendanceCreateWithoutPeriodInput[] | AttendanceUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutPeriodInput | AttendanceCreateOrConnectWithoutPeriodInput[]
    createMany?: AttendanceCreateManyPeriodInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type CkpScoreUncheckedCreateNestedManyWithoutPeriodInput = {
    create?: XOR<CkpScoreCreateWithoutPeriodInput, CkpScoreUncheckedCreateWithoutPeriodInput> | CkpScoreCreateWithoutPeriodInput[] | CkpScoreUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: CkpScoreCreateOrConnectWithoutPeriodInput | CkpScoreCreateOrConnectWithoutPeriodInput[]
    createMany?: CkpScoreCreateManyPeriodInputEnvelope
    connect?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
  }

  export type FinalEvaluationUncheckedCreateNestedManyWithoutPeriodInput = {
    create?: XOR<FinalEvaluationCreateWithoutPeriodInput, FinalEvaluationUncheckedCreateWithoutPeriodInput> | FinalEvaluationCreateWithoutPeriodInput[] | FinalEvaluationUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: FinalEvaluationCreateOrConnectWithoutPeriodInput | FinalEvaluationCreateOrConnectWithoutPeriodInput[]
    createMany?: FinalEvaluationCreateManyPeriodInputEnvelope
    connect?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EvaluationUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<EvaluationCreateWithoutPeriodInput, EvaluationUncheckedCreateWithoutPeriodInput> | EvaluationCreateWithoutPeriodInput[] | EvaluationUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutPeriodInput | EvaluationCreateOrConnectWithoutPeriodInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutPeriodInput | EvaluationUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: EvaluationCreateManyPeriodInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutPeriodInput | EvaluationUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutPeriodInput | EvaluationUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<AttendanceCreateWithoutPeriodInput, AttendanceUncheckedCreateWithoutPeriodInput> | AttendanceCreateWithoutPeriodInput[] | AttendanceUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutPeriodInput | AttendanceCreateOrConnectWithoutPeriodInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutPeriodInput | AttendanceUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: AttendanceCreateManyPeriodInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutPeriodInput | AttendanceUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutPeriodInput | AttendanceUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type CkpScoreUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<CkpScoreCreateWithoutPeriodInput, CkpScoreUncheckedCreateWithoutPeriodInput> | CkpScoreCreateWithoutPeriodInput[] | CkpScoreUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: CkpScoreCreateOrConnectWithoutPeriodInput | CkpScoreCreateOrConnectWithoutPeriodInput[]
    upsert?: CkpScoreUpsertWithWhereUniqueWithoutPeriodInput | CkpScoreUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: CkpScoreCreateManyPeriodInputEnvelope
    set?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    disconnect?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    delete?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    connect?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    update?: CkpScoreUpdateWithWhereUniqueWithoutPeriodInput | CkpScoreUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: CkpScoreUpdateManyWithWhereWithoutPeriodInput | CkpScoreUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: CkpScoreScalarWhereInput | CkpScoreScalarWhereInput[]
  }

  export type FinalEvaluationUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<FinalEvaluationCreateWithoutPeriodInput, FinalEvaluationUncheckedCreateWithoutPeriodInput> | FinalEvaluationCreateWithoutPeriodInput[] | FinalEvaluationUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: FinalEvaluationCreateOrConnectWithoutPeriodInput | FinalEvaluationCreateOrConnectWithoutPeriodInput[]
    upsert?: FinalEvaluationUpsertWithWhereUniqueWithoutPeriodInput | FinalEvaluationUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: FinalEvaluationCreateManyPeriodInputEnvelope
    set?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    disconnect?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    delete?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    connect?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    update?: FinalEvaluationUpdateWithWhereUniqueWithoutPeriodInput | FinalEvaluationUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: FinalEvaluationUpdateManyWithWhereWithoutPeriodInput | FinalEvaluationUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: FinalEvaluationScalarWhereInput | FinalEvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<EvaluationCreateWithoutPeriodInput, EvaluationUncheckedCreateWithoutPeriodInput> | EvaluationCreateWithoutPeriodInput[] | EvaluationUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutPeriodInput | EvaluationCreateOrConnectWithoutPeriodInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutPeriodInput | EvaluationUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: EvaluationCreateManyPeriodInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutPeriodInput | EvaluationUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutPeriodInput | EvaluationUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<AttendanceCreateWithoutPeriodInput, AttendanceUncheckedCreateWithoutPeriodInput> | AttendanceCreateWithoutPeriodInput[] | AttendanceUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutPeriodInput | AttendanceCreateOrConnectWithoutPeriodInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutPeriodInput | AttendanceUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: AttendanceCreateManyPeriodInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutPeriodInput | AttendanceUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutPeriodInput | AttendanceUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type CkpScoreUncheckedUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<CkpScoreCreateWithoutPeriodInput, CkpScoreUncheckedCreateWithoutPeriodInput> | CkpScoreCreateWithoutPeriodInput[] | CkpScoreUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: CkpScoreCreateOrConnectWithoutPeriodInput | CkpScoreCreateOrConnectWithoutPeriodInput[]
    upsert?: CkpScoreUpsertWithWhereUniqueWithoutPeriodInput | CkpScoreUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: CkpScoreCreateManyPeriodInputEnvelope
    set?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    disconnect?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    delete?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    connect?: CkpScoreWhereUniqueInput | CkpScoreWhereUniqueInput[]
    update?: CkpScoreUpdateWithWhereUniqueWithoutPeriodInput | CkpScoreUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: CkpScoreUpdateManyWithWhereWithoutPeriodInput | CkpScoreUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: CkpScoreScalarWhereInput | CkpScoreScalarWhereInput[]
  }

  export type FinalEvaluationUncheckedUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<FinalEvaluationCreateWithoutPeriodInput, FinalEvaluationUncheckedCreateWithoutPeriodInput> | FinalEvaluationCreateWithoutPeriodInput[] | FinalEvaluationUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: FinalEvaluationCreateOrConnectWithoutPeriodInput | FinalEvaluationCreateOrConnectWithoutPeriodInput[]
    upsert?: FinalEvaluationUpsertWithWhereUniqueWithoutPeriodInput | FinalEvaluationUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: FinalEvaluationCreateManyPeriodInputEnvelope
    set?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    disconnect?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    delete?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    connect?: FinalEvaluationWhereUniqueInput | FinalEvaluationWhereUniqueInput[]
    update?: FinalEvaluationUpdateWithWhereUniqueWithoutPeriodInput | FinalEvaluationUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: FinalEvaluationUpdateManyWithWhereWithoutPeriodInput | FinalEvaluationUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: FinalEvaluationScalarWhereInput | FinalEvaluationScalarWhereInput[]
  }

  export type EvaluationScoreCreateNestedManyWithoutParameterInput = {
    create?: XOR<EvaluationScoreCreateWithoutParameterInput, EvaluationScoreUncheckedCreateWithoutParameterInput> | EvaluationScoreCreateWithoutParameterInput[] | EvaluationScoreUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: EvaluationScoreCreateOrConnectWithoutParameterInput | EvaluationScoreCreateOrConnectWithoutParameterInput[]
    createMany?: EvaluationScoreCreateManyParameterInputEnvelope
    connect?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
  }

  export type EvaluationScoreUncheckedCreateNestedManyWithoutParameterInput = {
    create?: XOR<EvaluationScoreCreateWithoutParameterInput, EvaluationScoreUncheckedCreateWithoutParameterInput> | EvaluationScoreCreateWithoutParameterInput[] | EvaluationScoreUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: EvaluationScoreCreateOrConnectWithoutParameterInput | EvaluationScoreCreateOrConnectWithoutParameterInput[]
    createMany?: EvaluationScoreCreateManyParameterInputEnvelope
    connect?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
  }

  export type EvaluationScoreUpdateManyWithoutParameterNestedInput = {
    create?: XOR<EvaluationScoreCreateWithoutParameterInput, EvaluationScoreUncheckedCreateWithoutParameterInput> | EvaluationScoreCreateWithoutParameterInput[] | EvaluationScoreUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: EvaluationScoreCreateOrConnectWithoutParameterInput | EvaluationScoreCreateOrConnectWithoutParameterInput[]
    upsert?: EvaluationScoreUpsertWithWhereUniqueWithoutParameterInput | EvaluationScoreUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: EvaluationScoreCreateManyParameterInputEnvelope
    set?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    disconnect?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    delete?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    connect?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    update?: EvaluationScoreUpdateWithWhereUniqueWithoutParameterInput | EvaluationScoreUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: EvaluationScoreUpdateManyWithWhereWithoutParameterInput | EvaluationScoreUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: EvaluationScoreScalarWhereInput | EvaluationScoreScalarWhereInput[]
  }

  export type EvaluationScoreUncheckedUpdateManyWithoutParameterNestedInput = {
    create?: XOR<EvaluationScoreCreateWithoutParameterInput, EvaluationScoreUncheckedCreateWithoutParameterInput> | EvaluationScoreCreateWithoutParameterInput[] | EvaluationScoreUncheckedCreateWithoutParameterInput[]
    connectOrCreate?: EvaluationScoreCreateOrConnectWithoutParameterInput | EvaluationScoreCreateOrConnectWithoutParameterInput[]
    upsert?: EvaluationScoreUpsertWithWhereUniqueWithoutParameterInput | EvaluationScoreUpsertWithWhereUniqueWithoutParameterInput[]
    createMany?: EvaluationScoreCreateManyParameterInputEnvelope
    set?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    disconnect?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    delete?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    connect?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    update?: EvaluationScoreUpdateWithWhereUniqueWithoutParameterInput | EvaluationScoreUpdateWithWhereUniqueWithoutParameterInput[]
    updateMany?: EvaluationScoreUpdateManyWithWhereWithoutParameterInput | EvaluationScoreUpdateManyWithWhereWithoutParameterInput[]
    deleteMany?: EvaluationScoreScalarWhereInput | EvaluationScoreScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEvaluationsGivenInput = {
    create?: XOR<UserCreateWithoutEvaluationsGivenInput, UserUncheckedCreateWithoutEvaluationsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvaluationsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEvaluationsReceivedInput = {
    create?: XOR<UserCreateWithoutEvaluationsReceivedInput, UserUncheckedCreateWithoutEvaluationsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvaluationsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type PeriodCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<PeriodCreateWithoutEvaluationsInput, PeriodUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: PeriodCreateOrConnectWithoutEvaluationsInput
    connect?: PeriodWhereUniqueInput
  }

  export type EvaluationScoreCreateNestedManyWithoutEvaluationInput = {
    create?: XOR<EvaluationScoreCreateWithoutEvaluationInput, EvaluationScoreUncheckedCreateWithoutEvaluationInput> | EvaluationScoreCreateWithoutEvaluationInput[] | EvaluationScoreUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: EvaluationScoreCreateOrConnectWithoutEvaluationInput | EvaluationScoreCreateOrConnectWithoutEvaluationInput[]
    createMany?: EvaluationScoreCreateManyEvaluationInputEnvelope
    connect?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
  }

  export type EvaluationScoreUncheckedCreateNestedManyWithoutEvaluationInput = {
    create?: XOR<EvaluationScoreCreateWithoutEvaluationInput, EvaluationScoreUncheckedCreateWithoutEvaluationInput> | EvaluationScoreCreateWithoutEvaluationInput[] | EvaluationScoreUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: EvaluationScoreCreateOrConnectWithoutEvaluationInput | EvaluationScoreCreateOrConnectWithoutEvaluationInput[]
    createMany?: EvaluationScoreCreateManyEvaluationInputEnvelope
    connect?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
  }

  export type EnumEvaluationStatusFieldUpdateOperationsInput = {
    set?: $Enums.EvaluationStatus
  }

  export type UserUpdateOneRequiredWithoutEvaluationsGivenNestedInput = {
    create?: XOR<UserCreateWithoutEvaluationsGivenInput, UserUncheckedCreateWithoutEvaluationsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvaluationsGivenInput
    upsert?: UserUpsertWithoutEvaluationsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEvaluationsGivenInput, UserUpdateWithoutEvaluationsGivenInput>, UserUncheckedUpdateWithoutEvaluationsGivenInput>
  }

  export type UserUpdateOneRequiredWithoutEvaluationsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutEvaluationsReceivedInput, UserUncheckedCreateWithoutEvaluationsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvaluationsReceivedInput
    upsert?: UserUpsertWithoutEvaluationsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEvaluationsReceivedInput, UserUpdateWithoutEvaluationsReceivedInput>, UserUncheckedUpdateWithoutEvaluationsReceivedInput>
  }

  export type PeriodUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<PeriodCreateWithoutEvaluationsInput, PeriodUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: PeriodCreateOrConnectWithoutEvaluationsInput
    upsert?: PeriodUpsertWithoutEvaluationsInput
    connect?: PeriodWhereUniqueInput
    update?: XOR<XOR<PeriodUpdateToOneWithWhereWithoutEvaluationsInput, PeriodUpdateWithoutEvaluationsInput>, PeriodUncheckedUpdateWithoutEvaluationsInput>
  }

  export type EvaluationScoreUpdateManyWithoutEvaluationNestedInput = {
    create?: XOR<EvaluationScoreCreateWithoutEvaluationInput, EvaluationScoreUncheckedCreateWithoutEvaluationInput> | EvaluationScoreCreateWithoutEvaluationInput[] | EvaluationScoreUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: EvaluationScoreCreateOrConnectWithoutEvaluationInput | EvaluationScoreCreateOrConnectWithoutEvaluationInput[]
    upsert?: EvaluationScoreUpsertWithWhereUniqueWithoutEvaluationInput | EvaluationScoreUpsertWithWhereUniqueWithoutEvaluationInput[]
    createMany?: EvaluationScoreCreateManyEvaluationInputEnvelope
    set?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    disconnect?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    delete?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    connect?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    update?: EvaluationScoreUpdateWithWhereUniqueWithoutEvaluationInput | EvaluationScoreUpdateWithWhereUniqueWithoutEvaluationInput[]
    updateMany?: EvaluationScoreUpdateManyWithWhereWithoutEvaluationInput | EvaluationScoreUpdateManyWithWhereWithoutEvaluationInput[]
    deleteMany?: EvaluationScoreScalarWhereInput | EvaluationScoreScalarWhereInput[]
  }

  export type EvaluationScoreUncheckedUpdateManyWithoutEvaluationNestedInput = {
    create?: XOR<EvaluationScoreCreateWithoutEvaluationInput, EvaluationScoreUncheckedCreateWithoutEvaluationInput> | EvaluationScoreCreateWithoutEvaluationInput[] | EvaluationScoreUncheckedCreateWithoutEvaluationInput[]
    connectOrCreate?: EvaluationScoreCreateOrConnectWithoutEvaluationInput | EvaluationScoreCreateOrConnectWithoutEvaluationInput[]
    upsert?: EvaluationScoreUpsertWithWhereUniqueWithoutEvaluationInput | EvaluationScoreUpsertWithWhereUniqueWithoutEvaluationInput[]
    createMany?: EvaluationScoreCreateManyEvaluationInputEnvelope
    set?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    disconnect?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    delete?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    connect?: EvaluationScoreWhereUniqueInput | EvaluationScoreWhereUniqueInput[]
    update?: EvaluationScoreUpdateWithWhereUniqueWithoutEvaluationInput | EvaluationScoreUpdateWithWhereUniqueWithoutEvaluationInput[]
    updateMany?: EvaluationScoreUpdateManyWithWhereWithoutEvaluationInput | EvaluationScoreUpdateManyWithWhereWithoutEvaluationInput[]
    deleteMany?: EvaluationScoreScalarWhereInput | EvaluationScoreScalarWhereInput[]
  }

  export type EvaluationCreateNestedOneWithoutScoresInput = {
    create?: XOR<EvaluationCreateWithoutScoresInput, EvaluationUncheckedCreateWithoutScoresInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutScoresInput
    connect?: EvaluationWhereUniqueInput
  }

  export type EvaluationParameterCreateNestedOneWithoutEvaluationScoresInput = {
    create?: XOR<EvaluationParameterCreateWithoutEvaluationScoresInput, EvaluationParameterUncheckedCreateWithoutEvaluationScoresInput>
    connectOrCreate?: EvaluationParameterCreateOrConnectWithoutEvaluationScoresInput
    connect?: EvaluationParameterWhereUniqueInput
  }

  export type EvaluationUpdateOneRequiredWithoutScoresNestedInput = {
    create?: XOR<EvaluationCreateWithoutScoresInput, EvaluationUncheckedCreateWithoutScoresInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutScoresInput
    upsert?: EvaluationUpsertWithoutScoresInput
    connect?: EvaluationWhereUniqueInput
    update?: XOR<XOR<EvaluationUpdateToOneWithWhereWithoutScoresInput, EvaluationUpdateWithoutScoresInput>, EvaluationUncheckedUpdateWithoutScoresInput>
  }

  export type EvaluationParameterUpdateOneRequiredWithoutEvaluationScoresNestedInput = {
    create?: XOR<EvaluationParameterCreateWithoutEvaluationScoresInput, EvaluationParameterUncheckedCreateWithoutEvaluationScoresInput>
    connectOrCreate?: EvaluationParameterCreateOrConnectWithoutEvaluationScoresInput
    upsert?: EvaluationParameterUpsertWithoutEvaluationScoresInput
    connect?: EvaluationParameterWhereUniqueInput
    update?: XOR<XOR<EvaluationParameterUpdateToOneWithWhereWithoutEvaluationScoresInput, EvaluationParameterUpdateWithoutEvaluationScoresInput>, EvaluationParameterUncheckedUpdateWithoutEvaluationScoresInput>
  }

  export type UserCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    connect?: UserWhereUniqueInput
  }

  export type PeriodCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<PeriodCreateWithoutAttendancesInput, PeriodUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: PeriodCreateOrConnectWithoutAttendancesInput
    connect?: PeriodWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAttendancesInput
    upsert?: UserUpsertWithoutAttendancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAttendancesInput, UserUpdateWithoutAttendancesInput>, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type PeriodUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<PeriodCreateWithoutAttendancesInput, PeriodUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: PeriodCreateOrConnectWithoutAttendancesInput
    upsert?: PeriodUpsertWithoutAttendancesInput
    connect?: PeriodWhereUniqueInput
    update?: XOR<XOR<PeriodUpdateToOneWithWhereWithoutAttendancesInput, PeriodUpdateWithoutAttendancesInput>, PeriodUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserCreateNestedOneWithoutCkpScoresInput = {
    create?: XOR<UserCreateWithoutCkpScoresInput, UserUncheckedCreateWithoutCkpScoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutCkpScoresInput
    connect?: UserWhereUniqueInput
  }

  export type PeriodCreateNestedOneWithoutCkpScoresInput = {
    create?: XOR<PeriodCreateWithoutCkpScoresInput, PeriodUncheckedCreateWithoutCkpScoresInput>
    connectOrCreate?: PeriodCreateOrConnectWithoutCkpScoresInput
    connect?: PeriodWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCkpScoresNestedInput = {
    create?: XOR<UserCreateWithoutCkpScoresInput, UserUncheckedCreateWithoutCkpScoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutCkpScoresInput
    upsert?: UserUpsertWithoutCkpScoresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCkpScoresInput, UserUpdateWithoutCkpScoresInput>, UserUncheckedUpdateWithoutCkpScoresInput>
  }

  export type PeriodUpdateOneRequiredWithoutCkpScoresNestedInput = {
    create?: XOR<PeriodCreateWithoutCkpScoresInput, PeriodUncheckedCreateWithoutCkpScoresInput>
    connectOrCreate?: PeriodCreateOrConnectWithoutCkpScoresInput
    upsert?: PeriodUpsertWithoutCkpScoresInput
    connect?: PeriodWhereUniqueInput
    update?: XOR<XOR<PeriodUpdateToOneWithWhereWithoutCkpScoresInput, PeriodUpdateWithoutCkpScoresInput>, PeriodUncheckedUpdateWithoutCkpScoresInput>
  }

  export type UserCreateNestedOneWithoutFinalEvaluationsInput = {
    create?: XOR<UserCreateWithoutFinalEvaluationsInput, UserUncheckedCreateWithoutFinalEvaluationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinalEvaluationsInput
    connect?: UserWhereUniqueInput
  }

  export type PeriodCreateNestedOneWithoutFinalEvaluationsInput = {
    create?: XOR<PeriodCreateWithoutFinalEvaluationsInput, PeriodUncheckedCreateWithoutFinalEvaluationsInput>
    connectOrCreate?: PeriodCreateOrConnectWithoutFinalEvaluationsInput
    connect?: PeriodWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFinalEvaluationsNestedInput = {
    create?: XOR<UserCreateWithoutFinalEvaluationsInput, UserUncheckedCreateWithoutFinalEvaluationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFinalEvaluationsInput
    upsert?: UserUpsertWithoutFinalEvaluationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFinalEvaluationsInput, UserUpdateWithoutFinalEvaluationsInput>, UserUncheckedUpdateWithoutFinalEvaluationsInput>
  }

  export type PeriodUpdateOneRequiredWithoutFinalEvaluationsNestedInput = {
    create?: XOR<PeriodCreateWithoutFinalEvaluationsInput, PeriodUncheckedCreateWithoutFinalEvaluationsInput>
    connectOrCreate?: PeriodCreateOrConnectWithoutFinalEvaluationsInput
    upsert?: PeriodUpsertWithoutFinalEvaluationsInput
    connect?: PeriodWhereUniqueInput
    update?: XOR<XOR<PeriodUpdateToOneWithWhereWithoutFinalEvaluationsInput, PeriodUpdateWithoutFinalEvaluationsInput>, PeriodUncheckedUpdateWithoutFinalEvaluationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEvaluationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EvaluationStatus | EnumEvaluationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EvaluationStatus[] | ListEnumEvaluationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvaluationStatus[] | ListEnumEvaluationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEvaluationStatusFilter<$PrismaModel> | $Enums.EvaluationStatus
  }

  export type NestedEnumEvaluationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvaluationStatus | EnumEvaluationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EvaluationStatus[] | ListEnumEvaluationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvaluationStatus[] | ListEnumEvaluationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEvaluationStatusWithAggregatesFilter<$PrismaModel> | $Enums.EvaluationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvaluationStatusFilter<$PrismaModel>
    _max?: NestedEnumEvaluationStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EvaluationCreateWithoutEvaluatorInput = {
    id?: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    target: UserCreateNestedOneWithoutEvaluationsReceivedInput
    period: PeriodCreateNestedOneWithoutEvaluationsInput
    scores?: EvaluationScoreCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutEvaluatorInput = {
    id?: string
    periodId: string
    targetUserId: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    scores?: EvaluationScoreUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutEvaluatorInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput>
  }

  export type EvaluationCreateManyEvaluatorInputEnvelope = {
    data: EvaluationCreateManyEvaluatorInput | EvaluationCreateManyEvaluatorInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutTargetInput = {
    id?: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluator: UserCreateNestedOneWithoutEvaluationsGivenInput
    period: PeriodCreateNestedOneWithoutEvaluationsInput
    scores?: EvaluationScoreCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutTargetInput = {
    id?: string
    evaluatorId: string
    periodId: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    scores?: EvaluationScoreUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutTargetInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutTargetInput, EvaluationUncheckedCreateWithoutTargetInput>
  }

  export type EvaluationCreateManyTargetInputEnvelope = {
    data: EvaluationCreateManyTargetInput | EvaluationCreateManyTargetInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutUserInput = {
    id?: string
    persentaseTotal?: number
    tidakKerja?: number
    pulangAwal?: number
    telat?: number
    absenApel?: number
    cuti?: number
    totalMinus?: number
    nilaiPresensi?: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    period: PeriodCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutUserInput = {
    id?: string
    periodId: string
    persentaseTotal?: number
    tidakKerja?: number
    pulangAwal?: number
    telat?: number
    absenApel?: number
    cuti?: number
    totalMinus?: number
    nilaiPresensi?: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceCreateManyUserInputEnvelope = {
    data: AttendanceCreateManyUserInput | AttendanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CkpScoreCreateWithoutUserInput = {
    id?: string
    score: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    period: PeriodCreateNestedOneWithoutCkpScoresInput
  }

  export type CkpScoreUncheckedCreateWithoutUserInput = {
    id?: string
    periodId: string
    score: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CkpScoreCreateOrConnectWithoutUserInput = {
    where: CkpScoreWhereUniqueInput
    create: XOR<CkpScoreCreateWithoutUserInput, CkpScoreUncheckedCreateWithoutUserInput>
  }

  export type CkpScoreCreateManyUserInputEnvelope = {
    data: CkpScoreCreateManyUserInput | CkpScoreCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FinalEvaluationCreateWithoutUserInput = {
    id?: string
    berakhlakScore?: number
    presensiScore?: number
    ckpScore?: number
    finalScore?: number
    totalEvaluators?: number
    ranking?: number | null
    isBestEmployee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    period: PeriodCreateNestedOneWithoutFinalEvaluationsInput
  }

  export type FinalEvaluationUncheckedCreateWithoutUserInput = {
    id?: string
    periodId: string
    berakhlakScore?: number
    presensiScore?: number
    ckpScore?: number
    finalScore?: number
    totalEvaluators?: number
    ranking?: number | null
    isBestEmployee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinalEvaluationCreateOrConnectWithoutUserInput = {
    where: FinalEvaluationWhereUniqueInput
    create: XOR<FinalEvaluationCreateWithoutUserInput, FinalEvaluationUncheckedCreateWithoutUserInput>
  }

  export type FinalEvaluationCreateManyUserInputEnvelope = {
    data: FinalEvaluationCreateManyUserInput | FinalEvaluationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationUpsertWithWhereUniqueWithoutEvaluatorInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutEvaluatorInput, EvaluationUncheckedUpdateWithoutEvaluatorInput>
    create: XOR<EvaluationCreateWithoutEvaluatorInput, EvaluationUncheckedCreateWithoutEvaluatorInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutEvaluatorInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutEvaluatorInput, EvaluationUncheckedUpdateWithoutEvaluatorInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutEvaluatorInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutEvaluatorInput>
  }

  export type EvaluationScalarWhereInput = {
    AND?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    OR?: EvaluationScalarWhereInput[]
    NOT?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    id?: StringFilter<"Evaluation"> | string
    evaluatorId?: StringFilter<"Evaluation"> | string
    periodId?: StringFilter<"Evaluation"> | string
    targetUserId?: StringFilter<"Evaluation"> | string
    ranking?: IntFilter<"Evaluation"> | number
    status?: EnumEvaluationStatusFilter<"Evaluation"> | $Enums.EvaluationStatus
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeFilter<"Evaluation"> | Date | string
  }

  export type EvaluationUpsertWithWhereUniqueWithoutTargetInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutTargetInput, EvaluationUncheckedUpdateWithoutTargetInput>
    create: XOR<EvaluationCreateWithoutTargetInput, EvaluationUncheckedCreateWithoutTargetInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutTargetInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutTargetInput, EvaluationUncheckedUpdateWithoutTargetInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutTargetInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutTargetInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
    create: XOR<AttendanceCreateWithoutUserInput, AttendanceUncheckedCreateWithoutUserInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutUserInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutUserInput, AttendanceUncheckedUpdateWithoutUserInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutUserInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutUserInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    userId?: StringFilter<"Attendance"> | string
    periodId?: StringFilter<"Attendance"> | string
    persentaseTotal?: FloatFilter<"Attendance"> | number
    tidakKerja?: FloatFilter<"Attendance"> | number
    pulangAwal?: FloatFilter<"Attendance"> | number
    telat?: FloatFilter<"Attendance"> | number
    absenApel?: FloatFilter<"Attendance"> | number
    cuti?: FloatFilter<"Attendance"> | number
    totalMinus?: FloatFilter<"Attendance"> | number
    nilaiPresensi?: FloatFilter<"Attendance"> | number
    keterangan?: StringNullableFilter<"Attendance"> | string | null
    inputBy?: StringFilter<"Attendance"> | string
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    updatedAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type CkpScoreUpsertWithWhereUniqueWithoutUserInput = {
    where: CkpScoreWhereUniqueInput
    update: XOR<CkpScoreUpdateWithoutUserInput, CkpScoreUncheckedUpdateWithoutUserInput>
    create: XOR<CkpScoreCreateWithoutUserInput, CkpScoreUncheckedCreateWithoutUserInput>
  }

  export type CkpScoreUpdateWithWhereUniqueWithoutUserInput = {
    where: CkpScoreWhereUniqueInput
    data: XOR<CkpScoreUpdateWithoutUserInput, CkpScoreUncheckedUpdateWithoutUserInput>
  }

  export type CkpScoreUpdateManyWithWhereWithoutUserInput = {
    where: CkpScoreScalarWhereInput
    data: XOR<CkpScoreUpdateManyMutationInput, CkpScoreUncheckedUpdateManyWithoutUserInput>
  }

  export type CkpScoreScalarWhereInput = {
    AND?: CkpScoreScalarWhereInput | CkpScoreScalarWhereInput[]
    OR?: CkpScoreScalarWhereInput[]
    NOT?: CkpScoreScalarWhereInput | CkpScoreScalarWhereInput[]
    id?: StringFilter<"CkpScore"> | string
    userId?: StringFilter<"CkpScore"> | string
    periodId?: StringFilter<"CkpScore"> | string
    score?: FloatFilter<"CkpScore"> | number
    keterangan?: StringNullableFilter<"CkpScore"> | string | null
    inputBy?: StringFilter<"CkpScore"> | string
    createdAt?: DateTimeFilter<"CkpScore"> | Date | string
    updatedAt?: DateTimeFilter<"CkpScore"> | Date | string
  }

  export type FinalEvaluationUpsertWithWhereUniqueWithoutUserInput = {
    where: FinalEvaluationWhereUniqueInput
    update: XOR<FinalEvaluationUpdateWithoutUserInput, FinalEvaluationUncheckedUpdateWithoutUserInput>
    create: XOR<FinalEvaluationCreateWithoutUserInput, FinalEvaluationUncheckedCreateWithoutUserInput>
  }

  export type FinalEvaluationUpdateWithWhereUniqueWithoutUserInput = {
    where: FinalEvaluationWhereUniqueInput
    data: XOR<FinalEvaluationUpdateWithoutUserInput, FinalEvaluationUncheckedUpdateWithoutUserInput>
  }

  export type FinalEvaluationUpdateManyWithWhereWithoutUserInput = {
    where: FinalEvaluationScalarWhereInput
    data: XOR<FinalEvaluationUpdateManyMutationInput, FinalEvaluationUncheckedUpdateManyWithoutUserInput>
  }

  export type FinalEvaluationScalarWhereInput = {
    AND?: FinalEvaluationScalarWhereInput | FinalEvaluationScalarWhereInput[]
    OR?: FinalEvaluationScalarWhereInput[]
    NOT?: FinalEvaluationScalarWhereInput | FinalEvaluationScalarWhereInput[]
    id?: StringFilter<"FinalEvaluation"> | string
    userId?: StringFilter<"FinalEvaluation"> | string
    periodId?: StringFilter<"FinalEvaluation"> | string
    berakhlakScore?: FloatFilter<"FinalEvaluation"> | number
    presensiScore?: FloatFilter<"FinalEvaluation"> | number
    ckpScore?: FloatFilter<"FinalEvaluation"> | number
    finalScore?: FloatFilter<"FinalEvaluation"> | number
    totalEvaluators?: IntFilter<"FinalEvaluation"> | number
    ranking?: IntNullableFilter<"FinalEvaluation"> | number | null
    isBestEmployee?: BoolFilter<"FinalEvaluation"> | boolean
    createdAt?: DateTimeFilter<"FinalEvaluation"> | Date | string
    updatedAt?: DateTimeFilter<"FinalEvaluation"> | Date | string
  }

  export type EvaluationCreateWithoutPeriodInput = {
    id?: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluator: UserCreateNestedOneWithoutEvaluationsGivenInput
    target: UserCreateNestedOneWithoutEvaluationsReceivedInput
    scores?: EvaluationScoreCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutPeriodInput = {
    id?: string
    evaluatorId: string
    targetUserId: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    scores?: EvaluationScoreUncheckedCreateNestedManyWithoutEvaluationInput
  }

  export type EvaluationCreateOrConnectWithoutPeriodInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutPeriodInput, EvaluationUncheckedCreateWithoutPeriodInput>
  }

  export type EvaluationCreateManyPeriodInputEnvelope = {
    data: EvaluationCreateManyPeriodInput | EvaluationCreateManyPeriodInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutPeriodInput = {
    id?: string
    persentaseTotal?: number
    tidakKerja?: number
    pulangAwal?: number
    telat?: number
    absenApel?: number
    cuti?: number
    totalMinus?: number
    nilaiPresensi?: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutPeriodInput = {
    id?: string
    userId: string
    persentaseTotal?: number
    tidakKerja?: number
    pulangAwal?: number
    telat?: number
    absenApel?: number
    cuti?: number
    totalMinus?: number
    nilaiPresensi?: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutPeriodInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutPeriodInput, AttendanceUncheckedCreateWithoutPeriodInput>
  }

  export type AttendanceCreateManyPeriodInputEnvelope = {
    data: AttendanceCreateManyPeriodInput | AttendanceCreateManyPeriodInput[]
    skipDuplicates?: boolean
  }

  export type CkpScoreCreateWithoutPeriodInput = {
    id?: string
    score: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCkpScoresInput
  }

  export type CkpScoreUncheckedCreateWithoutPeriodInput = {
    id?: string
    userId: string
    score: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CkpScoreCreateOrConnectWithoutPeriodInput = {
    where: CkpScoreWhereUniqueInput
    create: XOR<CkpScoreCreateWithoutPeriodInput, CkpScoreUncheckedCreateWithoutPeriodInput>
  }

  export type CkpScoreCreateManyPeriodInputEnvelope = {
    data: CkpScoreCreateManyPeriodInput | CkpScoreCreateManyPeriodInput[]
    skipDuplicates?: boolean
  }

  export type FinalEvaluationCreateWithoutPeriodInput = {
    id?: string
    berakhlakScore?: number
    presensiScore?: number
    ckpScore?: number
    finalScore?: number
    totalEvaluators?: number
    ranking?: number | null
    isBestEmployee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFinalEvaluationsInput
  }

  export type FinalEvaluationUncheckedCreateWithoutPeriodInput = {
    id?: string
    userId: string
    berakhlakScore?: number
    presensiScore?: number
    ckpScore?: number
    finalScore?: number
    totalEvaluators?: number
    ranking?: number | null
    isBestEmployee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinalEvaluationCreateOrConnectWithoutPeriodInput = {
    where: FinalEvaluationWhereUniqueInput
    create: XOR<FinalEvaluationCreateWithoutPeriodInput, FinalEvaluationUncheckedCreateWithoutPeriodInput>
  }

  export type FinalEvaluationCreateManyPeriodInputEnvelope = {
    data: FinalEvaluationCreateManyPeriodInput | FinalEvaluationCreateManyPeriodInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationUpsertWithWhereUniqueWithoutPeriodInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutPeriodInput, EvaluationUncheckedUpdateWithoutPeriodInput>
    create: XOR<EvaluationCreateWithoutPeriodInput, EvaluationUncheckedCreateWithoutPeriodInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutPeriodInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutPeriodInput, EvaluationUncheckedUpdateWithoutPeriodInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutPeriodInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutPeriodInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutPeriodInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutPeriodInput, AttendanceUncheckedUpdateWithoutPeriodInput>
    create: XOR<AttendanceCreateWithoutPeriodInput, AttendanceUncheckedCreateWithoutPeriodInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutPeriodInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutPeriodInput, AttendanceUncheckedUpdateWithoutPeriodInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutPeriodInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutPeriodInput>
  }

  export type CkpScoreUpsertWithWhereUniqueWithoutPeriodInput = {
    where: CkpScoreWhereUniqueInput
    update: XOR<CkpScoreUpdateWithoutPeriodInput, CkpScoreUncheckedUpdateWithoutPeriodInput>
    create: XOR<CkpScoreCreateWithoutPeriodInput, CkpScoreUncheckedCreateWithoutPeriodInput>
  }

  export type CkpScoreUpdateWithWhereUniqueWithoutPeriodInput = {
    where: CkpScoreWhereUniqueInput
    data: XOR<CkpScoreUpdateWithoutPeriodInput, CkpScoreUncheckedUpdateWithoutPeriodInput>
  }

  export type CkpScoreUpdateManyWithWhereWithoutPeriodInput = {
    where: CkpScoreScalarWhereInput
    data: XOR<CkpScoreUpdateManyMutationInput, CkpScoreUncheckedUpdateManyWithoutPeriodInput>
  }

  export type FinalEvaluationUpsertWithWhereUniqueWithoutPeriodInput = {
    where: FinalEvaluationWhereUniqueInput
    update: XOR<FinalEvaluationUpdateWithoutPeriodInput, FinalEvaluationUncheckedUpdateWithoutPeriodInput>
    create: XOR<FinalEvaluationCreateWithoutPeriodInput, FinalEvaluationUncheckedCreateWithoutPeriodInput>
  }

  export type FinalEvaluationUpdateWithWhereUniqueWithoutPeriodInput = {
    where: FinalEvaluationWhereUniqueInput
    data: XOR<FinalEvaluationUpdateWithoutPeriodInput, FinalEvaluationUncheckedUpdateWithoutPeriodInput>
  }

  export type FinalEvaluationUpdateManyWithWhereWithoutPeriodInput = {
    where: FinalEvaluationScalarWhereInput
    data: XOR<FinalEvaluationUpdateManyMutationInput, FinalEvaluationUncheckedUpdateManyWithoutPeriodInput>
  }

  export type EvaluationScoreCreateWithoutParameterInput = {
    id?: string
    score: number
    createdAt?: Date | string
    evaluation: EvaluationCreateNestedOneWithoutScoresInput
  }

  export type EvaluationScoreUncheckedCreateWithoutParameterInput = {
    id?: string
    evaluationId: string
    score: number
    createdAt?: Date | string
  }

  export type EvaluationScoreCreateOrConnectWithoutParameterInput = {
    where: EvaluationScoreWhereUniqueInput
    create: XOR<EvaluationScoreCreateWithoutParameterInput, EvaluationScoreUncheckedCreateWithoutParameterInput>
  }

  export type EvaluationScoreCreateManyParameterInputEnvelope = {
    data: EvaluationScoreCreateManyParameterInput | EvaluationScoreCreateManyParameterInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationScoreUpsertWithWhereUniqueWithoutParameterInput = {
    where: EvaluationScoreWhereUniqueInput
    update: XOR<EvaluationScoreUpdateWithoutParameterInput, EvaluationScoreUncheckedUpdateWithoutParameterInput>
    create: XOR<EvaluationScoreCreateWithoutParameterInput, EvaluationScoreUncheckedCreateWithoutParameterInput>
  }

  export type EvaluationScoreUpdateWithWhereUniqueWithoutParameterInput = {
    where: EvaluationScoreWhereUniqueInput
    data: XOR<EvaluationScoreUpdateWithoutParameterInput, EvaluationScoreUncheckedUpdateWithoutParameterInput>
  }

  export type EvaluationScoreUpdateManyWithWhereWithoutParameterInput = {
    where: EvaluationScoreScalarWhereInput
    data: XOR<EvaluationScoreUpdateManyMutationInput, EvaluationScoreUncheckedUpdateManyWithoutParameterInput>
  }

  export type EvaluationScoreScalarWhereInput = {
    AND?: EvaluationScoreScalarWhereInput | EvaluationScoreScalarWhereInput[]
    OR?: EvaluationScoreScalarWhereInput[]
    NOT?: EvaluationScoreScalarWhereInput | EvaluationScoreScalarWhereInput[]
    id?: StringFilter<"EvaluationScore"> | string
    evaluationId?: StringFilter<"EvaluationScore"> | string
    parameterId?: StringFilter<"EvaluationScore"> | string
    score?: IntFilter<"EvaluationScore"> | number
    createdAt?: DateTimeFilter<"EvaluationScore"> | Date | string
  }

  export type UserCreateWithoutEvaluationsGivenInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationsReceived?: EvaluationCreateNestedManyWithoutTargetInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    ckpScores?: CkpScoreCreateNestedManyWithoutUserInput
    finalEvaluations?: FinalEvaluationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEvaluationsGivenInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationsReceived?: EvaluationUncheckedCreateNestedManyWithoutTargetInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    ckpScores?: CkpScoreUncheckedCreateNestedManyWithoutUserInput
    finalEvaluations?: FinalEvaluationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEvaluationsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEvaluationsGivenInput, UserUncheckedCreateWithoutEvaluationsGivenInput>
  }

  export type UserCreateWithoutEvaluationsReceivedInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationsGiven?: EvaluationCreateNestedManyWithoutEvaluatorInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    ckpScores?: CkpScoreCreateNestedManyWithoutUserInput
    finalEvaluations?: FinalEvaluationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEvaluationsReceivedInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationsGiven?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    ckpScores?: CkpScoreUncheckedCreateNestedManyWithoutUserInput
    finalEvaluations?: FinalEvaluationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEvaluationsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEvaluationsReceivedInput, UserUncheckedCreateWithoutEvaluationsReceivedInput>
  }

  export type PeriodCreateWithoutEvaluationsInput = {
    id?: string
    tahun: number
    bulan: number
    namaPeriode: string
    noPeriode?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceCreateNestedManyWithoutPeriodInput
    ckpScores?: CkpScoreCreateNestedManyWithoutPeriodInput
    finalEvaluations?: FinalEvaluationCreateNestedManyWithoutPeriodInput
  }

  export type PeriodUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    tahun: number
    bulan: number
    namaPeriode: string
    noPeriode?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceUncheckedCreateNestedManyWithoutPeriodInput
    ckpScores?: CkpScoreUncheckedCreateNestedManyWithoutPeriodInput
    finalEvaluations?: FinalEvaluationUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type PeriodCreateOrConnectWithoutEvaluationsInput = {
    where: PeriodWhereUniqueInput
    create: XOR<PeriodCreateWithoutEvaluationsInput, PeriodUncheckedCreateWithoutEvaluationsInput>
  }

  export type EvaluationScoreCreateWithoutEvaluationInput = {
    id?: string
    score: number
    createdAt?: Date | string
    parameter: EvaluationParameterCreateNestedOneWithoutEvaluationScoresInput
  }

  export type EvaluationScoreUncheckedCreateWithoutEvaluationInput = {
    id?: string
    parameterId: string
    score: number
    createdAt?: Date | string
  }

  export type EvaluationScoreCreateOrConnectWithoutEvaluationInput = {
    where: EvaluationScoreWhereUniqueInput
    create: XOR<EvaluationScoreCreateWithoutEvaluationInput, EvaluationScoreUncheckedCreateWithoutEvaluationInput>
  }

  export type EvaluationScoreCreateManyEvaluationInputEnvelope = {
    data: EvaluationScoreCreateManyEvaluationInput | EvaluationScoreCreateManyEvaluationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEvaluationsGivenInput = {
    update: XOR<UserUpdateWithoutEvaluationsGivenInput, UserUncheckedUpdateWithoutEvaluationsGivenInput>
    create: XOR<UserCreateWithoutEvaluationsGivenInput, UserUncheckedCreateWithoutEvaluationsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEvaluationsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEvaluationsGivenInput, UserUncheckedUpdateWithoutEvaluationsGivenInput>
  }

  export type UserUpdateWithoutEvaluationsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationsReceived?: EvaluationUpdateManyWithoutTargetNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    ckpScores?: CkpScoreUpdateManyWithoutUserNestedInput
    finalEvaluations?: FinalEvaluationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEvaluationsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationsReceived?: EvaluationUncheckedUpdateManyWithoutTargetNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    ckpScores?: CkpScoreUncheckedUpdateManyWithoutUserNestedInput
    finalEvaluations?: FinalEvaluationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutEvaluationsReceivedInput = {
    update: XOR<UserUpdateWithoutEvaluationsReceivedInput, UserUncheckedUpdateWithoutEvaluationsReceivedInput>
    create: XOR<UserCreateWithoutEvaluationsReceivedInput, UserUncheckedCreateWithoutEvaluationsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEvaluationsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEvaluationsReceivedInput, UserUncheckedUpdateWithoutEvaluationsReceivedInput>
  }

  export type UserUpdateWithoutEvaluationsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationsGiven?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    ckpScores?: CkpScoreUpdateManyWithoutUserNestedInput
    finalEvaluations?: FinalEvaluationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEvaluationsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationsGiven?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    ckpScores?: CkpScoreUncheckedUpdateManyWithoutUserNestedInput
    finalEvaluations?: FinalEvaluationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PeriodUpsertWithoutEvaluationsInput = {
    update: XOR<PeriodUpdateWithoutEvaluationsInput, PeriodUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<PeriodCreateWithoutEvaluationsInput, PeriodUncheckedCreateWithoutEvaluationsInput>
    where?: PeriodWhereInput
  }

  export type PeriodUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: PeriodWhereInput
    data: XOR<PeriodUpdateWithoutEvaluationsInput, PeriodUncheckedUpdateWithoutEvaluationsInput>
  }

  export type PeriodUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    bulan?: IntFieldUpdateOperationsInput | number
    namaPeriode?: StringFieldUpdateOperationsInput | string
    noPeriode?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceUpdateManyWithoutPeriodNestedInput
    ckpScores?: CkpScoreUpdateManyWithoutPeriodNestedInput
    finalEvaluations?: FinalEvaluationUpdateManyWithoutPeriodNestedInput
  }

  export type PeriodUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    bulan?: IntFieldUpdateOperationsInput | number
    namaPeriode?: StringFieldUpdateOperationsInput | string
    noPeriode?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceUncheckedUpdateManyWithoutPeriodNestedInput
    ckpScores?: CkpScoreUncheckedUpdateManyWithoutPeriodNestedInput
    finalEvaluations?: FinalEvaluationUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type EvaluationScoreUpsertWithWhereUniqueWithoutEvaluationInput = {
    where: EvaluationScoreWhereUniqueInput
    update: XOR<EvaluationScoreUpdateWithoutEvaluationInput, EvaluationScoreUncheckedUpdateWithoutEvaluationInput>
    create: XOR<EvaluationScoreCreateWithoutEvaluationInput, EvaluationScoreUncheckedCreateWithoutEvaluationInput>
  }

  export type EvaluationScoreUpdateWithWhereUniqueWithoutEvaluationInput = {
    where: EvaluationScoreWhereUniqueInput
    data: XOR<EvaluationScoreUpdateWithoutEvaluationInput, EvaluationScoreUncheckedUpdateWithoutEvaluationInput>
  }

  export type EvaluationScoreUpdateManyWithWhereWithoutEvaluationInput = {
    where: EvaluationScoreScalarWhereInput
    data: XOR<EvaluationScoreUpdateManyMutationInput, EvaluationScoreUncheckedUpdateManyWithoutEvaluationInput>
  }

  export type EvaluationCreateWithoutScoresInput = {
    id?: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluator: UserCreateNestedOneWithoutEvaluationsGivenInput
    target: UserCreateNestedOneWithoutEvaluationsReceivedInput
    period: PeriodCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutScoresInput = {
    id?: string
    evaluatorId: string
    periodId: string
    targetUserId: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationCreateOrConnectWithoutScoresInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutScoresInput, EvaluationUncheckedCreateWithoutScoresInput>
  }

  export type EvaluationParameterCreateWithoutEvaluationScoresInput = {
    id?: string
    namaParameter: string
    deskripsi?: string | null
    kategori?: string
    urutan: number
    createdAt?: Date | string
  }

  export type EvaluationParameterUncheckedCreateWithoutEvaluationScoresInput = {
    id?: string
    namaParameter: string
    deskripsi?: string | null
    kategori?: string
    urutan: number
    createdAt?: Date | string
  }

  export type EvaluationParameterCreateOrConnectWithoutEvaluationScoresInput = {
    where: EvaluationParameterWhereUniqueInput
    create: XOR<EvaluationParameterCreateWithoutEvaluationScoresInput, EvaluationParameterUncheckedCreateWithoutEvaluationScoresInput>
  }

  export type EvaluationUpsertWithoutScoresInput = {
    update: XOR<EvaluationUpdateWithoutScoresInput, EvaluationUncheckedUpdateWithoutScoresInput>
    create: XOR<EvaluationCreateWithoutScoresInput, EvaluationUncheckedCreateWithoutScoresInput>
    where?: EvaluationWhereInput
  }

  export type EvaluationUpdateToOneWithWhereWithoutScoresInput = {
    where?: EvaluationWhereInput
    data: XOR<EvaluationUpdateWithoutScoresInput, EvaluationUncheckedUpdateWithoutScoresInput>
  }

  export type EvaluationUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluator?: UserUpdateOneRequiredWithoutEvaluationsGivenNestedInput
    target?: UserUpdateOneRequiredWithoutEvaluationsReceivedNestedInput
    period?: PeriodUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationParameterUpsertWithoutEvaluationScoresInput = {
    update: XOR<EvaluationParameterUpdateWithoutEvaluationScoresInput, EvaluationParameterUncheckedUpdateWithoutEvaluationScoresInput>
    create: XOR<EvaluationParameterCreateWithoutEvaluationScoresInput, EvaluationParameterUncheckedCreateWithoutEvaluationScoresInput>
    where?: EvaluationParameterWhereInput
  }

  export type EvaluationParameterUpdateToOneWithWhereWithoutEvaluationScoresInput = {
    where?: EvaluationParameterWhereInput
    data: XOR<EvaluationParameterUpdateWithoutEvaluationScoresInput, EvaluationParameterUncheckedUpdateWithoutEvaluationScoresInput>
  }

  export type EvaluationParameterUpdateWithoutEvaluationScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    namaParameter?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: StringFieldUpdateOperationsInput | string
    urutan?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationParameterUncheckedUpdateWithoutEvaluationScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    namaParameter?: StringFieldUpdateOperationsInput | string
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    kategori?: StringFieldUpdateOperationsInput | string
    urutan?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAttendancesInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationsGiven?: EvaluationCreateNestedManyWithoutEvaluatorInput
    evaluationsReceived?: EvaluationCreateNestedManyWithoutTargetInput
    ckpScores?: CkpScoreCreateNestedManyWithoutUserInput
    finalEvaluations?: FinalEvaluationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAttendancesInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationsGiven?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    evaluationsReceived?: EvaluationUncheckedCreateNestedManyWithoutTargetInput
    ckpScores?: CkpScoreUncheckedCreateNestedManyWithoutUserInput
    finalEvaluations?: FinalEvaluationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAttendancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
  }

  export type PeriodCreateWithoutAttendancesInput = {
    id?: string
    tahun: number
    bulan: number
    namaPeriode: string
    noPeriode?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutPeriodInput
    ckpScores?: CkpScoreCreateNestedManyWithoutPeriodInput
    finalEvaluations?: FinalEvaluationCreateNestedManyWithoutPeriodInput
  }

  export type PeriodUncheckedCreateWithoutAttendancesInput = {
    id?: string
    tahun: number
    bulan: number
    namaPeriode: string
    noPeriode?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPeriodInput
    ckpScores?: CkpScoreUncheckedCreateNestedManyWithoutPeriodInput
    finalEvaluations?: FinalEvaluationUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type PeriodCreateOrConnectWithoutAttendancesInput = {
    where: PeriodWhereUniqueInput
    create: XOR<PeriodCreateWithoutAttendancesInput, PeriodUncheckedCreateWithoutAttendancesInput>
  }

  export type UserUpsertWithoutAttendancesInput = {
    update: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
    create: XOR<UserCreateWithoutAttendancesInput, UserUncheckedCreateWithoutAttendancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAttendancesInput, UserUncheckedUpdateWithoutAttendancesInput>
  }

  export type UserUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationsGiven?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    evaluationsReceived?: EvaluationUpdateManyWithoutTargetNestedInput
    ckpScores?: CkpScoreUpdateManyWithoutUserNestedInput
    finalEvaluations?: FinalEvaluationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationsGiven?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    evaluationsReceived?: EvaluationUncheckedUpdateManyWithoutTargetNestedInput
    ckpScores?: CkpScoreUncheckedUpdateManyWithoutUserNestedInput
    finalEvaluations?: FinalEvaluationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PeriodUpsertWithoutAttendancesInput = {
    update: XOR<PeriodUpdateWithoutAttendancesInput, PeriodUncheckedUpdateWithoutAttendancesInput>
    create: XOR<PeriodCreateWithoutAttendancesInput, PeriodUncheckedCreateWithoutAttendancesInput>
    where?: PeriodWhereInput
  }

  export type PeriodUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: PeriodWhereInput
    data: XOR<PeriodUpdateWithoutAttendancesInput, PeriodUncheckedUpdateWithoutAttendancesInput>
  }

  export type PeriodUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    bulan?: IntFieldUpdateOperationsInput | number
    namaPeriode?: StringFieldUpdateOperationsInput | string
    noPeriode?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutPeriodNestedInput
    ckpScores?: CkpScoreUpdateManyWithoutPeriodNestedInput
    finalEvaluations?: FinalEvaluationUpdateManyWithoutPeriodNestedInput
  }

  export type PeriodUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    bulan?: IntFieldUpdateOperationsInput | number
    namaPeriode?: StringFieldUpdateOperationsInput | string
    noPeriode?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutPeriodNestedInput
    ckpScores?: CkpScoreUncheckedUpdateManyWithoutPeriodNestedInput
    finalEvaluations?: FinalEvaluationUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type UserCreateWithoutCkpScoresInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationsGiven?: EvaluationCreateNestedManyWithoutEvaluatorInput
    evaluationsReceived?: EvaluationCreateNestedManyWithoutTargetInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    finalEvaluations?: FinalEvaluationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCkpScoresInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationsGiven?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    evaluationsReceived?: EvaluationUncheckedCreateNestedManyWithoutTargetInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    finalEvaluations?: FinalEvaluationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCkpScoresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCkpScoresInput, UserUncheckedCreateWithoutCkpScoresInput>
  }

  export type PeriodCreateWithoutCkpScoresInput = {
    id?: string
    tahun: number
    bulan: number
    namaPeriode: string
    noPeriode?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutPeriodInput
    attendances?: AttendanceCreateNestedManyWithoutPeriodInput
    finalEvaluations?: FinalEvaluationCreateNestedManyWithoutPeriodInput
  }

  export type PeriodUncheckedCreateWithoutCkpScoresInput = {
    id?: string
    tahun: number
    bulan: number
    namaPeriode: string
    noPeriode?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPeriodInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutPeriodInput
    finalEvaluations?: FinalEvaluationUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type PeriodCreateOrConnectWithoutCkpScoresInput = {
    where: PeriodWhereUniqueInput
    create: XOR<PeriodCreateWithoutCkpScoresInput, PeriodUncheckedCreateWithoutCkpScoresInput>
  }

  export type UserUpsertWithoutCkpScoresInput = {
    update: XOR<UserUpdateWithoutCkpScoresInput, UserUncheckedUpdateWithoutCkpScoresInput>
    create: XOR<UserCreateWithoutCkpScoresInput, UserUncheckedCreateWithoutCkpScoresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCkpScoresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCkpScoresInput, UserUncheckedUpdateWithoutCkpScoresInput>
  }

  export type UserUpdateWithoutCkpScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationsGiven?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    evaluationsReceived?: EvaluationUpdateManyWithoutTargetNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    finalEvaluations?: FinalEvaluationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCkpScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationsGiven?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    evaluationsReceived?: EvaluationUncheckedUpdateManyWithoutTargetNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    finalEvaluations?: FinalEvaluationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PeriodUpsertWithoutCkpScoresInput = {
    update: XOR<PeriodUpdateWithoutCkpScoresInput, PeriodUncheckedUpdateWithoutCkpScoresInput>
    create: XOR<PeriodCreateWithoutCkpScoresInput, PeriodUncheckedCreateWithoutCkpScoresInput>
    where?: PeriodWhereInput
  }

  export type PeriodUpdateToOneWithWhereWithoutCkpScoresInput = {
    where?: PeriodWhereInput
    data: XOR<PeriodUpdateWithoutCkpScoresInput, PeriodUncheckedUpdateWithoutCkpScoresInput>
  }

  export type PeriodUpdateWithoutCkpScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    bulan?: IntFieldUpdateOperationsInput | number
    namaPeriode?: StringFieldUpdateOperationsInput | string
    noPeriode?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutPeriodNestedInput
    attendances?: AttendanceUpdateManyWithoutPeriodNestedInput
    finalEvaluations?: FinalEvaluationUpdateManyWithoutPeriodNestedInput
  }

  export type PeriodUncheckedUpdateWithoutCkpScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    bulan?: IntFieldUpdateOperationsInput | number
    namaPeriode?: StringFieldUpdateOperationsInput | string
    noPeriode?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutPeriodNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutPeriodNestedInput
    finalEvaluations?: FinalEvaluationUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type UserCreateWithoutFinalEvaluationsInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationsGiven?: EvaluationCreateNestedManyWithoutEvaluatorInput
    evaluationsReceived?: EvaluationCreateNestedManyWithoutTargetInput
    attendances?: AttendanceCreateNestedManyWithoutUserInput
    ckpScores?: CkpScoreCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFinalEvaluationsInput = {
    id?: string
    nip: string
    nama: string
    email?: string | null
    password: string
    role?: $Enums.Role
    jenisKelamin: $Enums.Gender
    tanggalLahir?: Date | string | null
    alamat?: string | null
    mobilePhone?: string | null
    pendidikanTerakhir?: string | null
    jabatan?: string | null
    golongan?: string | null
    status?: string
    instansi?: string | null
    kantor?: string | null
    username: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluationsGiven?: EvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
    evaluationsReceived?: EvaluationUncheckedCreateNestedManyWithoutTargetInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutUserInput
    ckpScores?: CkpScoreUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFinalEvaluationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFinalEvaluationsInput, UserUncheckedCreateWithoutFinalEvaluationsInput>
  }

  export type PeriodCreateWithoutFinalEvaluationsInput = {
    id?: string
    tahun: number
    bulan: number
    namaPeriode: string
    noPeriode?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationCreateNestedManyWithoutPeriodInput
    attendances?: AttendanceCreateNestedManyWithoutPeriodInput
    ckpScores?: CkpScoreCreateNestedManyWithoutPeriodInput
  }

  export type PeriodUncheckedCreateWithoutFinalEvaluationsInput = {
    id?: string
    tahun: number
    bulan: number
    namaPeriode: string
    noPeriode?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPeriodInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutPeriodInput
    ckpScores?: CkpScoreUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type PeriodCreateOrConnectWithoutFinalEvaluationsInput = {
    where: PeriodWhereUniqueInput
    create: XOR<PeriodCreateWithoutFinalEvaluationsInput, PeriodUncheckedCreateWithoutFinalEvaluationsInput>
  }

  export type UserUpsertWithoutFinalEvaluationsInput = {
    update: XOR<UserUpdateWithoutFinalEvaluationsInput, UserUncheckedUpdateWithoutFinalEvaluationsInput>
    create: XOR<UserCreateWithoutFinalEvaluationsInput, UserUncheckedCreateWithoutFinalEvaluationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFinalEvaluationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFinalEvaluationsInput, UserUncheckedUpdateWithoutFinalEvaluationsInput>
  }

  export type UserUpdateWithoutFinalEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationsGiven?: EvaluationUpdateManyWithoutEvaluatorNestedInput
    evaluationsReceived?: EvaluationUpdateManyWithoutTargetNestedInput
    attendances?: AttendanceUpdateManyWithoutUserNestedInput
    ckpScores?: CkpScoreUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFinalEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nip?: StringFieldUpdateOperationsInput | string
    nama?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    jenisKelamin?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    tanggalLahir?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    mobilePhone?: NullableStringFieldUpdateOperationsInput | string | null
    pendidikanTerakhir?: NullableStringFieldUpdateOperationsInput | string | null
    jabatan?: NullableStringFieldUpdateOperationsInput | string | null
    golongan?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    instansi?: NullableStringFieldUpdateOperationsInput | string | null
    kantor?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluationsGiven?: EvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
    evaluationsReceived?: EvaluationUncheckedUpdateManyWithoutTargetNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutUserNestedInput
    ckpScores?: CkpScoreUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PeriodUpsertWithoutFinalEvaluationsInput = {
    update: XOR<PeriodUpdateWithoutFinalEvaluationsInput, PeriodUncheckedUpdateWithoutFinalEvaluationsInput>
    create: XOR<PeriodCreateWithoutFinalEvaluationsInput, PeriodUncheckedCreateWithoutFinalEvaluationsInput>
    where?: PeriodWhereInput
  }

  export type PeriodUpdateToOneWithWhereWithoutFinalEvaluationsInput = {
    where?: PeriodWhereInput
    data: XOR<PeriodUpdateWithoutFinalEvaluationsInput, PeriodUncheckedUpdateWithoutFinalEvaluationsInput>
  }

  export type PeriodUpdateWithoutFinalEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    bulan?: IntFieldUpdateOperationsInput | number
    namaPeriode?: StringFieldUpdateOperationsInput | string
    noPeriode?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUpdateManyWithoutPeriodNestedInput
    attendances?: AttendanceUpdateManyWithoutPeriodNestedInput
    ckpScores?: CkpScoreUpdateManyWithoutPeriodNestedInput
  }

  export type PeriodUncheckedUpdateWithoutFinalEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tahun?: IntFieldUpdateOperationsInput | number
    bulan?: IntFieldUpdateOperationsInput | number
    namaPeriode?: StringFieldUpdateOperationsInput | string
    noPeriode?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationUncheckedUpdateManyWithoutPeriodNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutPeriodNestedInput
    ckpScores?: CkpScoreUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type EvaluationCreateManyEvaluatorInput = {
    id?: string
    periodId: string
    targetUserId: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationCreateManyTargetInput = {
    id?: string
    evaluatorId: string
    periodId: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyUserInput = {
    id?: string
    periodId: string
    persentaseTotal?: number
    tidakKerja?: number
    pulangAwal?: number
    telat?: number
    absenApel?: number
    cuti?: number
    totalMinus?: number
    nilaiPresensi?: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CkpScoreCreateManyUserInput = {
    id?: string
    periodId: string
    score: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinalEvaluationCreateManyUserInput = {
    id?: string
    periodId: string
    berakhlakScore?: number
    presensiScore?: number
    ckpScore?: number
    finalScore?: number
    totalEvaluators?: number
    ranking?: number | null
    isBestEmployee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateWithoutEvaluatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    target?: UserUpdateOneRequiredWithoutEvaluationsReceivedNestedInput
    period?: PeriodUpdateOneRequiredWithoutEvaluationsNestedInput
    scores?: EvaluationScoreUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutEvaluatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scores?: EvaluationScoreUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutEvaluatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluator?: UserUpdateOneRequiredWithoutEvaluationsGivenNestedInput
    period?: PeriodUpdateOneRequiredWithoutEvaluationsNestedInput
    scores?: EvaluationScoreUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scores?: EvaluationScoreUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutTargetInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    persentaseTotal?: FloatFieldUpdateOperationsInput | number
    tidakKerja?: FloatFieldUpdateOperationsInput | number
    pulangAwal?: FloatFieldUpdateOperationsInput | number
    telat?: FloatFieldUpdateOperationsInput | number
    absenApel?: FloatFieldUpdateOperationsInput | number
    cuti?: FloatFieldUpdateOperationsInput | number
    totalMinus?: FloatFieldUpdateOperationsInput | number
    nilaiPresensi?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: PeriodUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    persentaseTotal?: FloatFieldUpdateOperationsInput | number
    tidakKerja?: FloatFieldUpdateOperationsInput | number
    pulangAwal?: FloatFieldUpdateOperationsInput | number
    telat?: FloatFieldUpdateOperationsInput | number
    absenApel?: FloatFieldUpdateOperationsInput | number
    cuti?: FloatFieldUpdateOperationsInput | number
    totalMinus?: FloatFieldUpdateOperationsInput | number
    nilaiPresensi?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    persentaseTotal?: FloatFieldUpdateOperationsInput | number
    tidakKerja?: FloatFieldUpdateOperationsInput | number
    pulangAwal?: FloatFieldUpdateOperationsInput | number
    telat?: FloatFieldUpdateOperationsInput | number
    absenApel?: FloatFieldUpdateOperationsInput | number
    cuti?: FloatFieldUpdateOperationsInput | number
    totalMinus?: FloatFieldUpdateOperationsInput | number
    nilaiPresensi?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CkpScoreUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: PeriodUpdateOneRequiredWithoutCkpScoresNestedInput
  }

  export type CkpScoreUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CkpScoreUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinalEvaluationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    berakhlakScore?: FloatFieldUpdateOperationsInput | number
    presensiScore?: FloatFieldUpdateOperationsInput | number
    ckpScore?: FloatFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    totalEvaluators?: IntFieldUpdateOperationsInput | number
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    isBestEmployee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: PeriodUpdateOneRequiredWithoutFinalEvaluationsNestedInput
  }

  export type FinalEvaluationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    berakhlakScore?: FloatFieldUpdateOperationsInput | number
    presensiScore?: FloatFieldUpdateOperationsInput | number
    ckpScore?: FloatFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    totalEvaluators?: IntFieldUpdateOperationsInput | number
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    isBestEmployee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinalEvaluationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    berakhlakScore?: FloatFieldUpdateOperationsInput | number
    presensiScore?: FloatFieldUpdateOperationsInput | number
    ckpScore?: FloatFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    totalEvaluators?: IntFieldUpdateOperationsInput | number
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    isBestEmployee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationCreateManyPeriodInput = {
    id?: string
    evaluatorId: string
    targetUserId: string
    ranking: number
    status?: $Enums.EvaluationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceCreateManyPeriodInput = {
    id?: string
    userId: string
    persentaseTotal?: number
    tidakKerja?: number
    pulangAwal?: number
    telat?: number
    absenApel?: number
    cuti?: number
    totalMinus?: number
    nilaiPresensi?: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CkpScoreCreateManyPeriodInput = {
    id?: string
    userId: string
    score: number
    keterangan?: string | null
    inputBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinalEvaluationCreateManyPeriodInput = {
    id?: string
    userId: string
    berakhlakScore?: number
    presensiScore?: number
    ckpScore?: number
    finalScore?: number
    totalEvaluators?: number
    ranking?: number | null
    isBestEmployee?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluator?: UserUpdateOneRequiredWithoutEvaluationsGivenNestedInput
    target?: UserUpdateOneRequiredWithoutEvaluationsReceivedNestedInput
    scores?: EvaluationScoreUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scores?: EvaluationScoreUncheckedUpdateManyWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    targetUserId?: StringFieldUpdateOperationsInput | string
    ranking?: IntFieldUpdateOperationsInput | number
    status?: EnumEvaluationStatusFieldUpdateOperationsInput | $Enums.EvaluationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    persentaseTotal?: FloatFieldUpdateOperationsInput | number
    tidakKerja?: FloatFieldUpdateOperationsInput | number
    pulangAwal?: FloatFieldUpdateOperationsInput | number
    telat?: FloatFieldUpdateOperationsInput | number
    absenApel?: FloatFieldUpdateOperationsInput | number
    cuti?: FloatFieldUpdateOperationsInput | number
    totalMinus?: FloatFieldUpdateOperationsInput | number
    nilaiPresensi?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    persentaseTotal?: FloatFieldUpdateOperationsInput | number
    tidakKerja?: FloatFieldUpdateOperationsInput | number
    pulangAwal?: FloatFieldUpdateOperationsInput | number
    telat?: FloatFieldUpdateOperationsInput | number
    absenApel?: FloatFieldUpdateOperationsInput | number
    cuti?: FloatFieldUpdateOperationsInput | number
    totalMinus?: FloatFieldUpdateOperationsInput | number
    nilaiPresensi?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    persentaseTotal?: FloatFieldUpdateOperationsInput | number
    tidakKerja?: FloatFieldUpdateOperationsInput | number
    pulangAwal?: FloatFieldUpdateOperationsInput | number
    telat?: FloatFieldUpdateOperationsInput | number
    absenApel?: FloatFieldUpdateOperationsInput | number
    cuti?: FloatFieldUpdateOperationsInput | number
    totalMinus?: FloatFieldUpdateOperationsInput | number
    nilaiPresensi?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CkpScoreUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCkpScoresNestedInput
  }

  export type CkpScoreUncheckedUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CkpScoreUncheckedUpdateManyWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    keterangan?: NullableStringFieldUpdateOperationsInput | string | null
    inputBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinalEvaluationUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    berakhlakScore?: FloatFieldUpdateOperationsInput | number
    presensiScore?: FloatFieldUpdateOperationsInput | number
    ckpScore?: FloatFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    totalEvaluators?: IntFieldUpdateOperationsInput | number
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    isBestEmployee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFinalEvaluationsNestedInput
  }

  export type FinalEvaluationUncheckedUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    berakhlakScore?: FloatFieldUpdateOperationsInput | number
    presensiScore?: FloatFieldUpdateOperationsInput | number
    ckpScore?: FloatFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    totalEvaluators?: IntFieldUpdateOperationsInput | number
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    isBestEmployee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinalEvaluationUncheckedUpdateManyWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    berakhlakScore?: FloatFieldUpdateOperationsInput | number
    presensiScore?: FloatFieldUpdateOperationsInput | number
    ckpScore?: FloatFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    totalEvaluators?: IntFieldUpdateOperationsInput | number
    ranking?: NullableIntFieldUpdateOperationsInput | number | null
    isBestEmployee?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationScoreCreateManyParameterInput = {
    id?: string
    evaluationId: string
    score: number
    createdAt?: Date | string
  }

  export type EvaluationScoreUpdateWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluation?: EvaluationUpdateOneRequiredWithoutScoresNestedInput
  }

  export type EvaluationScoreUncheckedUpdateWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationScoreUncheckedUpdateManyWithoutParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationScoreCreateManyEvaluationInput = {
    id?: string
    parameterId: string
    score: number
    createdAt?: Date | string
  }

  export type EvaluationScoreUpdateWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameter?: EvaluationParameterUpdateOneRequiredWithoutEvaluationScoresNestedInput
  }

  export type EvaluationScoreUncheckedUpdateWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationScoreUncheckedUpdateManyWithoutEvaluationInput = {
    id?: StringFieldUpdateOperationsInput | string
    parameterId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}